const dataList = [
  {
    "id": "639ebb35f0ccae2b10e0fb64",
    "author_id": "56f3686f02c237a73a1a8acf",
    "tab": "share",
    "content": "<div class=\"markdown-text\"><p>CNode TG Channel 开启 !</p>\n<p>Channel 将定期推送最新技术文章、资讯以及活动，欢迎订阅！</p>\n<p><a href=\"https://t.me/cnode_js\">https://t.me/cnode_js</a></p>\n<p><img src=\"//static.cnodejs.org/FkwbDvoUIeRAccpPd6f53rgXwrDz\" alt=\"qrcode_tg_channel_cnode.png\"></p>\n<blockquote>\n<p>Tips: 订阅后点击 “设置- View Discussion” 即可加入交流群!</p>\n</blockquote>\n</div>",
    "title": "CNode - TG 频道",
    "last_reply_at": "2023-05-30T01:22:11.860Z",
    "good": false,
    "top": true,
    "reply_count": 11,
    "visit_count": 207548,
    "create_at": "2022-12-18T07:03:17.900Z",
    "author": {
      "loginname": "thonatos",
      "avatar_url": "https://avatars.githubusercontent.com/u/958063?v=4&s=120"
    }
  },
  {
    "id": "6262718079f90d94a6a0d2f5",
    "author_id": "4f447c2f0a8abae26e01b27d",
    "tab": "share",
    "content": "<div class=\"markdown-text\"><h2>概述</h2>\n<p>Node.js 刚刚发布了 18.0.0 版本，内置了 <code>fetch</code>、<code>node:test</code> 等标准模块。</p>\n<p><strong>一句话点评：std lib 在标准化，user lib 在精细化。</strong></p>\n<blockquote>\n<p>原文地址：<a href=\"https://zhuanlan.zhihu.com/p/502951532\">EggJS 知乎专栏</a>，求点赞。</p>\n</blockquote>\n<hr>\n<h2>如何快速体验</h2>\n<p>推荐用 <a href=\"https://github.com/Schniz/fnm\">fnm</a>，<a href=\"https://github.com/jasongin/nvs\">nvs</a>，<a href=\"https://github.com/nvm-sh/nvm\">nvm</a> 等 Node.js 版本管理器。</p>\n<pre class=\"prettyprint language-bash\"><code>$ fnm install 18\nInstalling Node v18.0.0 (arm64)\n\n$ fnm use 18\nUsing Node v18.0.0\n\n$ node -v\nv18.0.0\n</code></pre><p>需要注意的是，该版本不是 LTS 版本，请勿在生产环境使用，需要等到 2022-10-25 才会成为 LTS 版本。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/012135a1091b40ef807c8b6e3919bcce~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"image.png\" title=\"https://github.com/nodejs/Release\"></p>\n<h2>Looking to the future</h2>\n<blockquote>\n<p>The project is also continuing its ‘Next 10’ effort.  The goal of this effort is to reflect on what led to success in the first 10 years of Node.js and set the direction for success in the next 10.</p>\n</blockquote>\n<p>Node.js 官方启动了 <a href=\"https://github.com/nodejs/next-10\">next-10</a> 工作，并讨论出了<a href=\"https://github.com/nodejs/node/blob/master/doc/contributing/technical-priorities.md\">未来重要的几件事</a>：</p>\n<ul>\n<li>现代化的 HTTP</li>\n<li>友好的类型支持</li>\n<li>对初学者更友好的渐进式文档</li>\n<li>对 ECMAScript 规范的支持和及时跟进</li>\n<li>可观测性，包括 logging/metrics/tracing，以及 APM 等</li>\n<li>更好的多线程支持</li>\n<li>支持打包为单文件的分发方式</li>\n</ul>\n<p>譬如前面说的 Fetch 就和 Modern HTTP 的会议讨论有关，<a href=\"https://github.com/nodejs/next-10/blob/main/meetings/summit-jan-2022.md\">相关纪要</a>。</p>\n<blockquote>\n<p>6 月份的 OpenJS World 会议中将分享 ESM 和 Observability 进展，可以关注下相关动态。</p>\n</blockquote>\n<hr>\n<h2>Fetch API</h2>\n<p>前端同学应该都很熟悉<code>fetch()</code>这个 API，它提供了标准的网络请求能力，取代了远古的  XMLHttpRequest 。</p>\n<p>反观 Node.js 侧，官方提供的 <a href=\"https://nodejs.org/dist/latest-v18.x/docs/api/http.html#httprequesturl-options-callback\">http.request()</a>，太底层太基础了，用起来往往需要大量的封装。譬如 302 后自动跳转、文件上传、响应结果解析等等。</p>\n<p>因此在 Node.js 社区有非常多的上层请求库封装：</p>\n<ul>\n<li>曾经广受社区欢迎的 request 库去年<a href=\"https://github.com/request/request/issues/3142\">宣布停止维护</a>后，也引起了社区比较大的混乱。。</li>\n<li>我们 Egg 内置的是 <a href=\"https://www.npmjs.com/package/urllib\">urllib</a>，沉淀了阿里多年在网络请求上踩的坑，足够稳定，不过代码也有点久远了。</li>\n<li>更多参见 <a href=\"https://github.com/request/request/issues/3143\">Alternative libraries to request</a> 以及 <a href=\"https://zhuanlan.zhihu.com/p/415361629\">《天猪：那些你应该说再见的 npm 祖传老库》</a>。</li>\n</ul>\n<p><strong>去年 Node.js 官方推出了 <strong><a href=\"https://undici.nodejs.org/\"><strong>undici</strong></a></strong>，一个非常现代化的库，具备优越的性能，良好的扩展性，内置的 mock 等能力，集大成者。</strong></p>\n<blockquote>\n<p>undici 的命名也很有趣：A HTTP/1.1 client → 11 → Eleven → Undici，即意大利语的 11。</p>\n</blockquote>\n<p>从而 <strong>Node.js 终于内置了新的请求库</strong>，它遵循 <a href=\"https://fetch.spec.whatwg.org/\">Fetch 规范</a>，底层就是基于 undici 来实现的。</p>\n<pre class=\"prettyprint language-javascript\"><code>const res = await fetch(&#x27;https:&#x2F;&#x2F;nodejs.org&#x2F;api&#x2F;documentation.json&#x27;);\nif (res.ok) {\n  const data = await res.json();\n  console.log(data);\n}\n</code></pre><p>就这么简单，比 <a href=\"https://nodejs.org/dist/latest-v18.x/docs/api/http.html#httprequesturl-options-callback\">http.request()</a> 那一坨 callback-style 代码简洁多了，平时写个脚本啥的，不用再引入额外的类库了。</p>\n<p>全局增加了 fetch, FormData, Headers, Request, Response 这几个 API，以及 Web Streams API。</p>\n<p>目前还处于默认开启的实验性特性阶段，文档在 <a href=\"https://nodejs.org/dist/latest-v18.x/docs/api/globals.html#fetch\">Globals</a> 章节，近乎没有，有需要直接看 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API\">MDN 文档</a> 即可。</p>\n<p>可能是为了遵循规范， undici 的很多能力如 Mock，Proxy，Pool 等都没有提供出来。</p>\n<hr>\n<h2>Test Runner</h2>\n<p>单元测试很重要，很多新兴的编程语言都是会内置对应的能力，但前端这块一直都是由社区来实现，前端同学耳熟能详的 Test Runner 有 <a href=\"https://mochajs.org/\">Mocha</a>、<a href=\"https://jestjs.io/\">Jest</a>。</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F; mocha showcase\nimport assert from &#x27;assert&#x2F;strict&#x27;;\n\ndescribe(&#x27;test&#x2F;index.test.js&#x27;, () =&gt; {\n  it(&#x27;test1&#x27;, async () =&gt; {\n    const res = await fetch(&#x27;https:&#x2F;&#x2F;nodejs.org&#x2F;api&#x2F;documentation.json&#x27;);\n    assert(res.ok);\n  });\n  \n  it.skip(&#x27;skip some test&#x27;, () =&gt; {});\n});\n</code></pre><p>终于，Node.js 在 18.x 里官方支持了 <a href=\"https://nodejs.org/dist/latest-v18.x/docs/api/test.html\">Test 能力</a>：</p>\n<pre class=\"prettyprint language-javascript\"><code>import test from &#x27;node:test&#x27;;\nimport assert from &#x27;assert&#x2F;strict&#x27;;\n\n&#x2F;&#x2F; 等价于 describe()\ntest(&#x27;asynchronous passing test&#x27;, async () =&gt; {\n  const res = await fetch(&#x27;https:&#x2F;&#x2F;nodejs.org&#x2F;api&#x2F;documentation.json&#x27;);\n  assert(res.ok);\n});\n\ntest(&#x27;multi level test&#x27;, async (t) =&gt; {\n  &#x2F;&#x2F; 等价于 it()\n  await t.test(&#x27;subtest 1&#x27;, (t) =&gt; {\n    assert.strictEqual(1, 1);\n  });\n\n  await t.test(&#x27;subtest 2&#x27;, (t) =&gt; {\n    assert.strictEqual(2, 2);\n  });\n});\n\n&#x2F;&#x2F; 等价于 describe.skip() &#x2F; it.skip()\ntest(&#x27;skip option&#x27;, { skip: true }, () =&gt; {});\n\n&#x2F;&#x2F; 等价于 describe.only() &#x2F; it.only()\ntest(&#x27;only option&#x27;, { only: true }, () =&gt; {});\n</code></pre><p>可以看到：</p>\n<ul>\n<li>语法其实差不多，会更简洁一点，就一个 <code>test()</code>，options 除了 skip 和 only 外，还支持 concurrency 并发。</li>\n<li>无需启动器，每一个文件都是一个可执行的 Node.js 代码。</li>\n<li>暂未支持 <code>before/after/beforeEach/afterEach</code> 能力，看 issue 描述会后续支持。</li>\n<li>暂未支持 Reporter，但日志输出为标准 <a href=\"https://testanything.org/\">TAP</a> 格式，所以应该很容易能复用现有的社区生态。</li>\n</ul>\n<p>类似覆盖率的演进过程，以前我们需要通过 nyc 对代码转译打桩，现在变为的 Node.js 内置覆盖率输出，nyc 变为 c8 这样的覆盖率报告生成工具。</p>\n<p>后续 mocha 等估计会变为类似的上层封装，提供批量执行 和 Reporter 等能力。</p>\n<hr>\n<h2>Build-time user-land snapshot</h2>\n<p>简单的说，可以把某个 js 直接编译成 v8 snapshot，从而可以极大的提速启动时间。</p>\n<p>目前这个版本，还只能通过 Node.js 源码来编译，且只能编译成 Node.js Runtime 的方式，即 Build-time。</p>\n<pre class=\"prettyprint language-bash\"><code># 把一段 markdown 渲染的逻辑，直接打包到 Node Runtime\n$ cd &#x2F;path&#x2F;to&#x2F;node&#x2F;source\n$ .&#x2F;configure --node-snapshot-main=marked.js\n$ make node\n\n# 执行编译好的 Node Runtime\n$ out&#x2F;Release&#x2F;node\n&gt; const html = globalThis.marked(&#x27;# this is title&#x27;);\n</code></pre><p>秋怡正在继续推进<a href=\"https://github.com/nodejs/node/issues/35711\">该能力</a>，未来可以无需编译 Node.js 源码：</p>\n<pre class=\"prettyprint language-bash\"><code>$ node --build-snapshot --snapshot-blob marked.blob marked.js \n$ node --snapshot-blob marked.blob\n</code></pre><p>PS：这个能力用在命令行 CLI 的独立打包好像也不错。<a href=\"https://github.com/nodejs/node/issues/42566\">https://github.com/nodejs/node/issues/42566</a></p>\n<hr>\n<h2>V8 引擎升级</h2>\n<p>内置的 V8 引擎升级到 10.1 版本，值得注意的特性：</p>\n<ul>\n<li>class fields 和 private class methods 的性能优化。</li>\n<li><a href=\"https://v8.dev/blog/v8-release-99#intl.locale-extensions\">Intl 规范</a> 的支持，在做日期的本地化，字符串处理的时候非常有用。</li>\n<li>数组支持 findLast() 和 findLastIndex() 等。</li>\n</ul>\n<p>秋怡也写了一篇文章 <a href=\"https://v8.dev/blog/faster-class-features\">Faster initialization of instances with new class features</a> 分享了背后的实现。</p>\n<p>PS：<a href=\"https://mp.weixin.qq.com/s/6PTcjJQTED3WpJH8ToXInw\">ECMAScript 双月报告：装饰器提案进入 Stage 3</a> ，阿里的 Node 架构团队今年会推动 Decorator 方案在 V8 的落地实现，不过肯定赶不上了，只能 Node.js 20.x 见了。</p>\n<hr>\n<h2>ESM 的支持</h2>\n<p>虽然在 18.x 中没有新的内容，但在过去的几个月中一直在持续推动 ECMAScript模块实现：</p>\n<ul>\n<li>对 <a href=\"https://github.com/tc39/proposal-import-assertions\">JSON Import Assertions</a> 的支持。</li>\n<li>JSON 模块的正式支持。</li>\n<li>对 HTTPS 和 HTTP 导入的实验性支持。</li>\n<li><a href=\"https://github.com/nodejs/loaders\">Node.js 加载器团队</a>也在继续开发 ECMAScript 模块加载器实现。</li>\n</ul>\n<hr>\n<h2>工具链和编译器的升级</h2>\n<ul>\n<li>Linux 版是在 RHEL8 上构建的，要求 glibc 2.28 以上版本。</li>\n<li>macOS 要求 10.15 以上版本。</li>\n<li>Windows 很多旧版本也不支持了。</li>\n</ul>\n<p>PS：CentOS 7 官方不再维护了，它对应的 glibc 版本太低，所以升不了。。。</p>\n<ul>\n<li><a href=\"https://developer.aliyun.com/article/780803\">centos7和8不维护停止更新之后，服务器选择使用什么系统好？</a></li>\n<li><a href=\"https://github.com/nodejs/node/pull/42659\">doc: update minimum glibc requirements for Linux by richardlau</a></li>\n</ul>\n<hr>\n<h2>相关资料</h2>\n<ul>\n<li><a href=\"https://nodejs.org/en/blog/announcements/v18-release-announce\">https://nodejs.org/en/blog/announcements/v18-release-announce</a></li>\n<li><a href=\"https://nodejs.org/en/blog/release/v18.0.0/\">https://nodejs.org/en/blog/release/v18.0.0/</a></li>\n</ul>\n</div>",
    "title": "Node.js 18 新特性解读",
    "last_reply_at": "2023-05-05T13:09:24.797Z",
    "good": false,
    "top": true,
    "reply_count": 35,
    "visit_count": 121279,
    "create_at": "2022-04-22T09:12:32.716Z",
    "author": {
      "loginname": "atian25",
      "avatar_url": "https://avatars.githubusercontent.com/u/227713?v=4&s=120"
    }
  },
  {
    "id": "61f69e4aa08b39f75309c2a8",
    "author_id": "4efc278525fa69ac6900000f",
    "tab": "share",
    "content": "<div class=\"markdown-text\"><p><a href=\"https://registry.npmmirror.com\">https://registry.npmmirror.com</a> 中国 npm 镜像源在2013年12月开始就使用基于 koa 的 <a href=\"https://github.com/cnpm/cnpmjs.org\">https://github.com/cnpm/cnpmjs.org</a> 私有 npm 应用搭建，这些年 node 应用框架在快速换代升级，连我们自己造的 egg 都要升级到 TypeScript 了，所以在 2021 年我们启动了 <a href=\"http://cnpmjs.org\">cnpmjs.org</a> 的技术升级重构，基于 egg 的 TypeScript 模式重新实现 <a href=\"https://github.com/cnpm/cnpmcore\">https://github.com/cnpm/cnpmcore</a> 。</p>\n<p>npm registry 的接口是 100% 实现迁移，然后在数据同步上通过数据库实现足够简单的任务系统，已经在 2022年1月30日完全老数据迁移。\n非常感谢阿里云这么多年来的对中国 npm 镜像云服务器的开源赞助，只能靠仅有的广告位和每年的感谢帖子来回报这份天价的云资源账单。这一次重构之后，我们验证下来至少可以节省一半的云服务器资源，也算是让阿里云的开源赞助可以减轻一些成本负担。</p>\n<p>当然 cnpmcore 不仅仅是为了技术升级，我们的核心新能力会跟随 npmfs 黑科技在 2022 年发布出来，到时候 npm install 的安装速度会在 cli 侧和 registry 侧同时发力，让 npm 模块安装速度在可预见的未来达到秒级。</p>\n<p>PS：预估你在此期间遇到包数据同步和丢失问题，请先手动同步一次，如果还是没有，请回帖反馈给我们。</p>\n</div>",
    "title": "中国 npm 镜像源升级公告",
    "last_reply_at": "2023-05-05T13:07:12.548Z",
    "good": false,
    "top": true,
    "reply_count": 47,
    "visit_count": 185610,
    "create_at": "2022-01-30T14:18:50.170Z",
    "author": {
      "loginname": "fengmk2",
      "avatar_url": "https://avatars.githubusercontent.com/u/156269?v=4&s=120"
    }
  },
  {
    "id": "634fa473d3061fe5e4e88d35",
    "author_id": "516f989a6d38277306ae8c1b",
    "tab": "share",
    "content": "<div class=\"markdown-text\"><p>继 2019 年开源 Midway 框架之后，阿里一直在 Node.js 的前沿进行深度研究，除了加入 TC39 参与标准化建设，向上游 Node.js 项目持续贡献，与龙蜥社区合作优化之外，也在 Serverless 领域有了不小的成果。</p>\n<p>今天，向大家介绍我们最新的面向云原生场景，面向 Serverless 架构下的新产品， 代号 <strong>Noslate</strong>。</p>\n<h2>Noslate 是什么？</h2>\n<p>欢迎访问项目了解更多内容：<a href=\"https://github.com/noslate-project/noslate\">Noslate</a>\n<img src=\"https://gw.alicdn.com/imgextra/i4/O1CN01hh1Db41sqh60CiNhD_!!6000000005818-2-tps-1324-390.png\" alt=\"Noslate\">\nJavaScript 是开发者数量最庞大的编程语言，早些年 Node.js 等技术的出现，让 JavaScript 可以轻松地处理各类服务端任务。</p>\n<p>但随着云原生/Serverless 等新架构概念的引导，弹性效率成为了全新的架构设计目标。为了能够让 JavaScript 任务拥有更高的弹性效率，进而满足在泛终端、全栈交付等领域的效率期待。我们逐步深入探索的过程中逐渐形成了 Noslate Project，旨在提升云原生场景下 JavaScript 的被调度性能，解决诊断性黑盒问题。</p>\n<p>Noslate 它主要由三个子项目组成，分别体现了我们在提升 Javascript 任务弹性效率过程中碰到的问题以及解决方式：</p>\n<ol>\n<li>Node.js Distribution：初期针对函数计算冷启动场景优化，降低 Node.js 用户代码加载耗时，形成了针对性的 Node.js 发行版本。</li>\n<li>Noslate Workers：随着探索的深入，我们设计了面向轻量端云同构场景的 W3C Web-interoperable JavaScript 轻量化容器方案。在交付灵活度上和资源、执行效率上形成平衡，现在主要应用于中心化的 SSR 渲染等轻量任务场景，效果显著。</li>\n<li>Noslate Debugger：在落地业务过程中，我们发现在弹性效率提升后，对于异常和崩溃变得难以定位，得益于 Linux 系统 Coredump 机制的启发，我们设计了基于 Corefile 对问题进行离线诊断的 Noslate Debugger 产品，帮助用户实现问题的回溯和实时定位。</li>\n</ol>\n<p>简而言之，Noslate 目标是通过提供完整的技术产品方案， 将 JavaScript 打造成云原生时代最灵活的交付语言。</p>\n<h2>为什么开源？</h2>\n<p>一方面我们希望通过开源加强项目产品化程度；另一方面希望在社区中吸收更多的实践场景进而继续完善产品设计，也欢迎大家参与到项目中来。\n同时，依托阿里云龙蜥社区和 Anolis 操作系统的合作关系，我们得以在底层探索，实现技术的演进。</p>\n<h3>一、Noslate Workers</h3>\n<p><img src=\"https://gw.alicdn.com/imgextra/i4/O1CN01L6QLHh1NRjQD5l5PE_!!6000000001567-2-tps-1270-339.png\" alt=\"Noslate Workers\">\nW3C Web-interoperable 运行时 Aworker，提供了一个轻量，近乎 0 冷启动的 JavaScript Serverless 运行环境。通过它，可以轻松的在已有的架构中集成轻量化类 Serverless 的能力。\n<img src=\"https://gw.alicdn.com/imgextra/i2/O1CN015XmQ8e20OlsVamGdC_!!6000000006840-2-tps-1729-672.png\" alt=\"Noslate Workers 架构\">\n与传统的 FaaS 架构不同，这是一个在普通应用容器之上的轻量任务单位。得益于良好的动态任务高密度混部和隔离特性、以及基于任务状态拷贝 API 带来的近乎 0 冷启动特性，可以实现任务的即用即启与即停即抛，进而无需关心在整个大集群中任务节点的编排问题。\n与既有架构的关系：\n<img src=\"https://gw.alicdn.com/imgextra/i3/O1CN01hwla1u1WSUch3qhT0_!!6000000002787-0-tps-3337-1879.jpg\" alt=\"弹性架构分层\">\nNoslate Workers 由两个主要组件组成：</p>\n<ol>\n<li>Aworker - 轻量、Web-interoperable JavaScript Runtime</li>\n<li>Noslated - Serverless 化的 Aworker 调度管控实现</li>\n</ol>\n<h4>关于 Aworker</h4>\n<p>提供 Web API 标准的 Web-interoperable JavaScript 运行时，适合不直接依赖系统接口的业务逻辑部署。 Aworker 实现了近似 <a href=\"https://www.w3.org/TR/service-workers/\">Service Worker API</a> 的规范，提供了基本的 <a href=\"https://www.w3.org/TR/service-workers/#fetchevent\">Request-Response</a> 服务 API。\n因为提供了相比于 Node.js 的 API 更加高层次、抽象的定义，不会泄漏系统底层状态，Aworker 通过 Startup Snapshot 和 Warmfork 能力， 实现了更快的水平及垂直扩容，能够在毫秒级启动并处理流量，具备更高的弹性效率。</p>\n<h5>亮点特性一、Warmfork</h5>\n<p>熟悉 Linux 系统编程的同学都知道 fork(2) 系统调用有几个优势：</p>\n<ol>\n<li>新进程可以继承母进程的当前状态，而无需从 main() 开始初始化；</li>\n<li>pcb、栈、内存页，页表都是纯内存复制，所以进程创建快 (&lt;1ms)；</li>\n<li>CopyOnWrite，新进程可以继承母进程的静态页表，可节省系统内存；</li>\n</ol>\n<p>对于 Node.js 来说，因为其无法在主线程持有所有多线程的状态 (如锁，信号量等)，所以 Node.js 进行 fork 的修改难度很大。其多线程设计主要 来源于 libuv 库和 V8 Platform Worker 线程：</p>\n<ol>\n<li>因部分 IO 操作存在同步调用，如 dns，文件读写等，所以 libuv 使用 IO 线程将同步操作转换成异步操作；</li>\n<li>Node.js 的 V8 默认配置为多线程 GC、Background Compilation/Optimization 的方式；</li>\n</ol>\n<p>Node.js 的单进程多线程模型可以由下图表示：\n<img src=\"https://gw.alicdn.com/imgextra/i1/O1CN01f3vkhU1gZxESjIBhq_!!6000000004157-2-tps-767-267.png\" alt=\"Node.js 单进程多线程模型\">\nAworker 的设计是采用单进程单线程的模型，也就是将上述模型中的 worker thread 单独抽出放到一独立进程中。Worker 因此可支持 fork，从而避免从 main() 开始的启动消耗，达到快速启动的目的。\n<img src=\"https://gw.alicdn.com/imgextra/i1/O1CN01vaKK3b1NniQw29c7a_!!6000000001615-2-tps-734-266.png\" alt=\"Aworker 单进程单线程模型\">\n为了支持单线程，Aworker 还做了如下修改：</p>\n<ol>\n<li>使用了 Linux AIO 特性替掉了 libuv 中同步的文件系统操作（不是 POSIX AIO，两者有区别。Posix AIO 类似于 libuv 现有的实现）；</li>\n<li>使用 V8 的 SingleThread 模式，这是一个给低端设备（Low-end devices）实现的能力，不过非常符合 Serverless 资源模型；</li>\n</ol>\n<p>而为了管理、隔离这些工作进程，我们设计了一个轻量的业务进程容器管理组件 Turf ，该组件能通过 Warmfork 方式创建新的 Aworker 服务进程，并能提供一定的资源、环境的隔离能力，同时兼容 OCI。区别于传统 runc, rund 的容器，turf 旨在承载如 Aworker 这类轻 JS Runtime，它无需镜像运行，开销更低，可以支持更高的部署密度。</p>\n<p>Warmfork 具体的对比：\n<img src=\"https://gw.alicdn.com/imgextra/i2/O1CN01cLR5kd1JGVFa2tPic_!!6000000001001-2-tps-480-391.png\" alt=\"warmfork\">\n提供 “被复制” 的进程，称为 “种子进程”，其他服务进程都是该进程的克隆。譬如 Aworker 作为种子进程，它需要确定自己一个 “可被克隆” 的时间点，将自己的所在状态（内存）作为克隆进程的初始状态。</p>\n<p>Warmfork 的系统时序如下：\n<img src=\"https://gw.alicdn.com/imgextra/i3/O1CN01dTl9w71ZcW8TdBOon_!!6000000003215-2-tps-675-386.png\" alt=\"warmfork 时序\"></p>\n<h5>亮点特性二、Startup Snapshot</h5>\n<p>Warmfork 能实现了单机上服务进程的快速启动，而对于优化冷机启动加载速度，需要采用 Startup Snapshot 方案。\nStartup Snapshot 和 CodeCache 的区别在于 Startup Snapshot 能够保存用户代码逻辑执行状态，而 CodeCache 只保存代码解析结果、仍然需要重新执行 用户代码逻辑。</p>\n<p>设计上，Startup Snapshot 可提供携带用户代码逻辑的快速恢复，但是也有局限性：</p>\n<ol>\n<li>Startup Snapshot 对内存开销敏感，如果应用启动阶段用了大量内存，可能造成负优化；</li>\n<li>用户代码启动需要没有歧义的状态，比如 IP 地址、日期、连接状态、服务发现结果等，针对这些歧义内容用户代码需要在进程恢复时有修正能力；</li>\n</ol>\n<p>V8 的 Startup Snapshot Serializer 就是一个类似于 GC 的对象遍历器。这个遍历器通过遍历加入到 Snapshot 中的 Root 对象，遍历它所对应的对象图并按照对象关系生成一系列的反序列化指令。</p>\n<p>Startup Snapshot 相当于从 V8 Context 对象与它的 globalThis 开始，遍历堆中所有的对象并将对象关系与引用序列化成 特有的字节码，形成一个线性的可存储状态。并在恢复时，解释执行这些字节码，恢复堆中的对象内容与他们之间的引用关系。\n<img src=\"https://gw.alicdn.com/imgextra/i3/O1CN01VbTxVV1j7xsJEqEGB_!!6000000004502-2-tps-750-390.png\" alt=\"V8 对象\">\n上述的两类和被调度性能相关的特性被统一归类为状态拷贝 API，具体使用可以参考官网文档中的<a href=\"https://noslate.midwayjs.org/docs/noslate_workers/aworker/serialize-api\">《状态拷贝 API》</a>章节，详细介绍了命令行参数和程序内的 Events。</p>\n<h4>Noslated</h4>\n<p>Noslate Container Deamon，作为 Noslate Workers 解决方案的核心管控程序，提供了实例调度、弹性扩缩容、配置管理、流量管理等能力。</p>\n<p>基于健壮性考虑，它由两个角色组成：控制面（Control Plane）、数据面（Data Plane）\n<img src=\"https://gw.alicdn.com/imgextra/i3/O1CN01OGE8Xk1hEiU0mY4Nw_!!6000000004246-2-tps-2845-1351.png\" alt=\"Noslated 架构\">\nNoslated 对于实例的管控主要有三个模式：</p>\n<ol>\n<li>基础模式 - 基于流量的扩缩容</li>\n<li>即抛模式 - 运行完即销毁</li>\n<li>预留模式 - 面向历史场景兼容，在此不额外展开，详情可以查阅官网<a href=\"https://noslate.midwayjs.org/docs/noslate_workers/references/scale/#%E4%B8%89%E9%A2%84%E7%95%99%E7%AD%96%E7%95%A5\">【预留策略】</a>。</li>\n</ol>\n<h5>一、基础模式</h5>\n<p>当流量进入 Data Plane 后，如果没有能够处理请求的 Worker 实例，会通过 requestQueueing 事件通知 Control Plane，它会根据当前水位决定扩容数量，如果当前已无法创建 Worker 实例，会返回资源上限报错。新的 Worker 实例启动后，会自动连接到 Data Plane，Data Plane 发现新的 Worker 实例连接后会主动触发初始化请求，初始化成功后开始消费请求队列里堆积的请求。</p>\n<p>当 Worker 实例闲置一段时间后，Control Plane 会主动发起 GC 操作，告知 Data Plane 关闭流量，流量关闭后，Control Plane 会通知 Turf 关闭 Worker 实例，清理资源残留。\n<img src=\"https://gw.alicdn.com/imgextra/i3/O1CN01TWklUC1OusEnQ5ENK_!!6000000001766-2-tps-1207-1020.png\" alt=\"基础弹性模式\"></p>\n<h5>二、即抛模式</h5>\n<p>针对特定的灵活场景，一次性的轻量用户脚本执行（比如特别高密度的混部执行二方任务如 SSR），为了隔离不同请求间的上下文，可以针对每个请求创建一个实例，并在执行后销毁。\n<img src=\"https://gw.alicdn.com/imgextra/i3/O1CN01k7ZGMG1DHWQzoQWSV_!!6000000000191-2-tps-1207-1020.png\" alt=\"即抛模式\">\n在常规 Node.js 实例带上业务逻辑启动一般都不会太快，如果直接用于响应用户流量 RT 会难以接受。得益于 Aworker 运行时的 Warmfork 以及 Startup Snapshot 能力，把部分业务初始化逻辑放置到 Warmfrok 特性中，进而让新实例都是更快的启动并具备响应能力，这才让高密度混部二方任务成为可能。</p>\n<h2>二、Noslate Debugger</h2>\n<p><img src=\"https://gw.alicdn.com/imgextra/i1/O1CN010OWgpL1yU9IWuE5XG_!!6000000006581-2-tps-1270-339.png\" alt=\"Noslate Debugger\">\nNoslate Debugger 是针对 V8 应用的离线分析工具，它可以分析 Node.js 等应用程序产生的 Corefile (Core 文件)：</p>\n<ol>\n<li>检查 Node.js/V8 应用程序的结构体、堆栈等内容</li>\n<li>检查 V8 堆内的各种对象信息</li>\n<li>从 Corefile 中导出 Heap Snapshot</li>\n<li>业务无感获取 Corefile (通过 Arthur 工具)</li>\n<li>已支持 Node.js / AWorker LTS 官方发行版</li>\n</ol>\n<p>为了更好的解决问题而不是造轮子，在未来的几个月 Noslate Debugger 也会和国内社区 Node.js 稳定性领域优秀的开源软件 Easy Monitor 共建整合，在 Node.js/V8 的问题诊断领域形成合力，也是值得期待的事情。</p>\n<h5>优点一：基于 Corefile 的 “快照” 更适应 Serverless</h5>\n<p>Serverless 应用通常会使用大量生命周期短、规格小的任务实例，但在此类任务实例上获得调试诊断能力并不容易，这使得 Serverless 应用长期处于较为黑盒的窘境。比如，Inspector 需要稳定和长时的网络连接、运行时 Heap Snapshot 需要较多的计算和内存资源，都是和 Serverless 架构背道而驰的。</p>\n<p>不管是 V8 的对象还是堆快照，它都是 “信息” 在内存中的存储，而 Inspector 功能就是可以在 “运行时” 能提取这些信息。Noslate Debugger 通过 Corefile 将这部分调试诊断能力转移到了离线时进行，让原有实时性要求高的在线诊断调试转化为只需简单文件上传即可集成使用。</p>\n<p>在用户本地或云端服务上提供接近用户本地开发时的调试诊断体感：\n<img src=\"https://gw.alicdn.com/imgextra/i2/O1CN01OCIltT1LGcaAR4r8G_!!6000000001272-2-tps-861-519.png\" alt=\"调试流程\"></p>\n<blockquote>\n<p>Corefile (特指 GNU Corefile 格式) 主要记录的是 Node.js 进程的内存和寄存器转储(CoreDump: 内存到磁盘的过程)。所以它也是进程完整“信息”，被用于 Linux 系统应用 Crash(有损) 的调试载体，也可用于 GCore(无损) 产生进程快照用于离线分析。</p>\n</blockquote>\n<h5>优点二：更小的业务影响​</h5>\n<p>对比原有线上 “堆快照” 对业务的影响长达数分钟，到只影响业务 RT 秒级（通过 GCore），甚至只有几十毫秒 （通过 Arthur 工具）。Corefile 快照也不会有任何运行时的&quot;添油加醋&quot;，所以它也适合那些还未被GC的对象定位，譬如诊断已经结束了的业务处理等。</p>\n<p>Arthur 是 Noslate Debugger 中用于低影响获取 core文件的工具，利用 fork 减少进程暂停时间，LZ4 压缩减少转储体积。带业务流量的线上环境抓取，业务影响 31.106 毫秒，Corefile 大小为 338 MB （进程原使用 1.44GB 物理内存）。</p>\n<h2>三、Node.js 发行版</h2>\n<p><img src=\"https://gw.alicdn.com/imgextra/i1/O1CN01wxGn641fHLWa312QP_!!6000000003981-2-tps-1270-339.png\" alt=\"Anode\">\n我们还对 Node.js 的实例进行了定向弹性场景的优化，提高了用户代码的加载速度，从而降低了冷启动时间。主要包括 Require 关系加速、Bytecode Cache，优化效果提升可高达 100% ~ 200%。该发行版，同时包含来自阿里云基础软件团队在 ARM 架构的性能优化特性。</p>\n<h3>冷启动优化</h3>\n<p>PGO（Profile Guided Optimization），是一种根据运行时 Profiling Data 来进行编译优化的技术，这里我们借鉴了这一概念。主要是通过执行一遍之后收集启动阶段的热点数据生成缓存文件，后续通过内存映射直接加载高效的缓存文件，即可获得提升在 100% ~ 200% 的用户代码冷启动优化效果。\n<img src=\"https://gw.alicdn.com/imgextra/i4/O1CN01nHx1UD1yE7Qqlfef6_!!6000000006546-2-tps-1164-930.png\" alt=\"PGO 流程\"></p>\n<h3>面向特定平台架构优化</h3>\n<p>Node.js 支持包括 x64、arm64 等在内的多种架构。 但针对 ARM 芯片的快速发展，上游版本往往仅提供基础适配，缺少针对新指令集的优化，导致在 ARM 芯片上无法获得潜在的性能提升。当下主流云厂商大都提供了 ARM 架构、高性价比的运行环境。 Noslate Node.js 发行版针对 ARM 等平台的优化可以让应用在这些架构上获得更高的性能和效率。\n目前 Noslate Node.js 发行版已经在进行针对阿里云 Ampere、阿里云倚天的定制优化，未来计划包括支持龙蜥社区中的其他架构。主要包括：zlib 特性优化、其他一些利用 SIMD 的性能提升都在 PR 合并和准别中。\n上面是对 Noslate Project 的简单介绍，如果想要详细了解可通过下述方式：\n● GitHub: <a href=\"https://github.com/noslate-project/noslate\">https://github.com/noslate-project/noslate </a>\n● 网站：<a href=\"https://noslate.midwayjs.org/\">https://noslate.midwayjs.org/</a>\n● 龙蜥社区 SIG（特殊兴趣小组，有钉钉群）：<a href=\"https://openanolis.cn/sig/web-platform\">https://openanolis.cn/sig/web-platform</a>\n● 邮件列表：noslate-support@list.alibaba-inc.com</p>\n<p>致谢\n感谢阿里巴巴集团内业务方的支持，同时还要特别感谢所有给本项目贡献过代码、一起探索过技术方向伙伴们（包括不限于 legendecas、mariodu、zhaolei0505、XadillaX、umuoy1、oraluben、hyj1991 等）。</p>\n</div>",
    "title": "阿里巴巴 Noslate 正式开源 - 面向云原生的 JavaScript 容器方案",
    "last_reply_at": "2023-01-03T08:20:08.069Z",
    "good": false,
    "top": true,
    "reply_count": 6,
    "visit_count": 169056,
    "create_at": "2022-10-19T07:17:07.977Z",
    "author": {
      "loginname": "mariodu",
      "avatar_url": "//gravatar.com/avatar/1cb272a2b4347c9a15b502ce7e4802ba?size=48"
    }
  },
  {
    "id": "5fdb44d70f99cb37f45e3410",
    "author_id": "56f3686f02c237a73a1a8acf",
    "tab": "share",
    "content": "<div class=\"markdown-text\"><p>RT.</p>\n<p>请大家遵守法律法规，勿发布不合规内容。</p>\n<ul>\n<li>2021/11/26：针对部分打擦边球的推广行为（如各种云服务商的推广链接），将会对账户做出屏蔽处理。</li>\n<li>2021/11/26：针对机器人频繁发布广告与违规内容，新增发帖限制如下：新用户五天内不允许发帖（不影响回帖）。</li>\n</ul>\n</div>",
    "title": "【2021/11/26】请大家遵纪守法，勿发布不合规内容",
    "last_reply_at": "2022-12-24T08:11:16.749Z",
    "good": false,
    "top": true,
    "reply_count": 283,
    "visit_count": 228861,
    "create_at": "2020-12-17T11:45:27.667Z",
    "author": {
      "loginname": "thonatos",
      "avatar_url": "https://avatars.githubusercontent.com/u/958063?v=4&s=120"
    }
  },
  {
    "id": "61dbd8fd994582918ef7d174",
    "author_id": "54009f5ccd66f2eb37190485",
    "tab": "share",
    "content": "<div class=\"markdown-text\"><p>很多人觉得Node.js没有往年那么火了，事实上不是这样的，Node.js社区健康稳步的发展中，主要是从性能好向好用转变，在易用性上有很大提升，从Node.js源码更新的内容看，大抵如此。Node.js Diagnostics Working Group是近二年Node.js社区的重点工作组，Node.js 14版本之后的大部分功能特性都是这个工作组推动的。早在2015年，有2个跟踪工作组tracing WG 和事后分析工作组 postmortem WG，在2017年合并到Diagnostics WG。核心产出是async_hooks, profiling, tracing, dump debug, report等，都是在易用性和好用性上做提升。让每个Node.js开发者更低门槛的提升Node.js应用的开发体验。</p>\n<p>秦粤老师在《浮华过后的Node.js》分享里，也表达了同样观点，他用的是产品化平缓期，也是健康稳步的发展的意思。</p>\n<p><img src=\"//static.cnodejs.org/FqRK1Uehhaz3lFDF3oHeL97Z7zYm\" alt=\"image.png\"></p>\n<p>社区方面，Web框架已经没有多少空间，以特性取胜的框架，应该不会很多，比较期待Egg3。像fastify这种，修改Node.js机制，在性能领域深耕的框架，目前看是比较有作为的。pnpm是有创新的，但代码是有点可读性不太好。我更加喜欢rushstack对menorepo的改进，大规模编程范式还需要探索。除了去年提的midway-hooks，easy-monitor，看起来remix和morden算新，但还没有超出之前的范畴。</p>\n<p>下面结合《<a href=\"https://nodersurvey.github.io/reporters\">Node.js开发者2021报告</a>》内容，我们详细解读一下Node.js 2021年的情况。这份解读是根据冰森&amp;狼叔直播内容整理的，要点如下。\n​</p>\n<h3>1）开发框架变化较大，造轮子变少，TS变多，使用企业级框架变多</h3>\n<p>​</p>\n<p>去年express占比还非常高，今年企业级框架变多，尤其是大而全的框架更受欢迎。</p>\n<p><img src=\"//static.cnodejs.org/Fl-QFKuag-dvFGbx7Q45WabMH5d8\" alt=\"image.png\"></p>\n<p>Egg在国内普及率很高，而Midway和Nest增长较快，其实和TS普及有一定关系。\n​\n<img src=\"//static.cnodejs.org/FvoNa6PGZJN1ZaqZlmXZuRnNUI5_\" alt=\"image.png\">\n​</p>\n<h3>2）版本更新变化较大，从Node 12升级到Node 14，升级比较积极</h3>\n<p>​</p>\n<p>去年Node.js主要是使用Node 12，2021年Node 14占比将近一半，更新还是较快的。</p>\n<p><img src=\"//static.cnodejs.org/FpQcq4qzd9rl-R-VEXzLZAiVMPaa\" alt=\"image.png\">\n​</p>\n<h3>3）吐槽变多，意味着用的人变多，趋于成熟</h3>\n<p>​</p>\n<p>C++之父Bjarne Stroustrup说过：世界上只有两种编程语言,一种是整天被人骂的,还有一种是没人用的。\n​</p>\n<p>大家对Node.js吐槽变多，实际上是在应用场景上使用较多，不再是针对于某些特性而进行吹捧。回归理性，在真实应用场景上，分布广泛，核心围绕API和BFF层，CLI&amp;工具。\n​\n<img src=\"//static.cnodejs.org/FkEeeI7hvEdSMIyUNaKxnQx9pzcJ\" alt=\"image.png\"></p>\n<h3>4）出圈：年龄分布较去年比变大，使用工种也变得比较丰富。</h3>\n<p>除了应用场景上，分布广泛外，非前端意外的开发者相关角色也有很大比例的提升，比如架构师，技术总监，项目经理等都一定程度上使用Node.js。可以说Node.js走出了前端圈，面向更大群体提供服务。另外受访者的年龄分布也变大了，这和出圈是有直接关系的。\n​\n<img src=\"//static.cnodejs.org/FsnHAf1Map8P8i4bEAn89POQf_8E\" alt=\"image.png\"></p>\n<h3>5）使用困惑：性能优化，内存泄漏以及npm依赖</h3>\n<p>​</p>\n<p>以往对Node.js困惑最多的是异步流程控制，随着async/await的普及，这个问题已经慢慢在弱化。随着开发者使用Node.js深度增加，对性能优化，内存泄漏更为关注，这也是比较容易理解的。</p>\n<p><img src=\"//static.cnodejs.org/FkPiwL5U9kbNq1vUE1J8AQKn54z4\" alt=\"image.png\"></p>\n<p>​</p>\n<h3>6）未来：从业经验越高则越关注性能和 Serverless</h3>\n<p>​</p>\n<p>关注性能比较容易理解，关注Serverless最主要是的原因是Serverless可以做到低运维甚至是0运维。运维作为Node.js开发者必备技能，Serverless的出现使得很多非专业Node.js也能轻松搞定Node.js各种服务端场景。</p>\n<p><img src=\"//static.cnodejs.org/FjZSOZ1uO-Tqh8yTL2E4CtvMUFbN\" alt=\"image.png\"></p>\n<p><img src=\"//static.cnodejs.org/FshPaWkMvnMKMxJckqf0L-M5OYe1\" alt=\"image.png\"></p>\n<h3>推荐阅读</h3>\n<ul>\n<li>天猪《EggJS 的前世今生与未来》，比较期待Egg3，easy-monitor作者一君也加入Egg3项目组了 <a href=\"https://www.yuque.com/atian25/blog/egg-1to2to3\">https://www.yuque.com/atian25/blog/egg-1to2to3</a></li>\n<li>秦粤 《浮华过后的Node.js》链接稍后给出来</li>\n</ul>\n<h3>参考</h3>\n<ul>\n<li>原文  <a href=\"https://cnodejs.org/topic/6108bbc2a5d29d175c2d4208\">https://cnodejs.org/topic/6108bbc2a5d29d175c2d4208</a></li>\n<li>报告 <a href=\"https://nodersurvey.github.io/reporters\">https://nodersurvey.github.io/reporters</a></li>\n</ul>\n<p>如果大家想参与讨论，欢迎回复</p>\n</div>",
    "title": "Node.js 2021年开发者报告解读：健康稳步的发展中",
    "last_reply_at": "2022-11-08T14:07:10.512Z",
    "good": false,
    "top": true,
    "reply_count": 19,
    "visit_count": 238304,
    "create_at": "2022-01-10T06:58:05.059Z",
    "author": {
      "loginname": "i5ting",
      "avatar_url": "https://avatars.githubusercontent.com/u/3118295?v=4&s=120"
    }
  },
  {
    "id": "64768c8556d98338ab9d9817",
    "author_id": "5186db7e6d382773067251ce",
    "tab": "share",
    "content": "<div class=\"markdown-text\"><blockquote>\n<p>Web3Hacker.World 是一个集合程序员黑客、对新事物好奇的种子用户、及 vc 投资者组合的围绕 <code>万物皆可 Web3</code> 的理念打造的生态体系。\n我们将持续分享 Web3 的最新技术发展，并打造一个开放式的黑客社区并产出真正非庞氏的 Web3 产品</p>\n</blockquote>\n<p>目前大部分 Web3 的文章教程都是在介绍一大堆的工具链等，在我们看来，有一些其实已经可以逐步淘汰了，未来非底层架构甚至开发其实都不用去碰的一些工具概念名词。\n而 Web3Hacker.World 则目标是打造一站式的 Web3 开发者工具链生态，所以我们本身会一直持续更新我们的技术架构以适应整体技术的发展变化。</p>\n<p>本文即我们在开发我们自己的开源应用钱包 BuidlerProtocol Wallet 时，研究新技术方案时碰到的，<code>wagmi</code> 这个项目是 16 个月前开始的，这过程中核心团队就 2 个人，\n他们开发非常活跃，到现在 <code>wagmi</code> 项目有 4.5k 的 star，而官方 Twitter <a href=\"/user/wagmi_sh\">@wagmi_sh</a> 有快 5k 的粉丝了。</p>\n<p><code>wagmi</code> 是 <code>We all gona make it</code> 的缩写。</p>\n<p>我们之前多个项目也一直使用 <code>ethers.js</code>，在综合考虑后，觉得全部逐步替换为 <code>wagmi</code> 和 <code>Viem</code>，我们将在这些项目替换：</p>\n<ul>\n<li>bs-craft(未开源，仅黑客会员可使用，未来会释放出精简版开源): 基于 nuxt3 layer 的一站式的 Web3 全栈开发解决方案</li>\n<li>BuidlerProtocol Wallet: 参加波卡黑客松的契机刚刚立项，将实现一个可以让 Twitter 用户发布 NFT 作为付费模式的浏览器插件钱包\n<ul>\n<li>此项目开源，欢迎有业余时间同学可以加入参与，未来会根据贡献分配奖励</li>\n</ul>\n</li>\n</ul>\n<p>另外我们还启动了好几个 Web3 及相关技术栈的翻译的开源项目，这些项目在未来也会通过 Web3Hacker.World 的开源基金会分发奖励，欢迎早期参与者加入贡献！</p>\n<ul>\n<li><a href=\"https://github.com/Web3Hacker-World/wagmicn.web3hacker.world\">Wagmi CN</a> 即本文翻译的站点 <a href=\"https://github.com/Web3Hacker-World/wagmicn.web3hacker.world\">https://github.com/Web3Hacker-World/wagmicn.web3hacker.world</a></li>\n<li><a href=\"https://github.com/Web3Hacker-World/viemcn.web3hacker.world\">Viem CN</a> 即本文翻译的站点 <a href=\"https://github.com/Web3Hacker-World/viemcn.web3hacker.world\">https://github.com/Web3Hacker-World/viemcn.web3hacker.world</a></li>\n<li><a href=\"https://github.com/Web3Hacker-World/nuxtcn.web3hacker.world\">Nuxt3 CN</a> Nuxt3 的相关文档翻译 <a href=\"https://github.com/Web3Hacker-World/nuxtcn.web3hacker.world\">https://github.com/Web3Hacker-World/nuxtcn.web3hacker.world</a></li>\n</ul>\n<p>以下为 <code>wagmi core</code> 的 <a href=\"https://wagmi.sh/core/getting-started\"><code>getting started</code></a> 翻译，注意，文中链接还未完全翻译，故可能导致访问 404，可以替换域名为 <code>wagmi.sh</code> 即可阅读英文原文，后续中文翻译完链接即可恢复。</p>\n<h1>开始</h1>\n<p><code>@wagmi/core</code> 是一个原生 JS 库，包含开始使用以太坊所需的一切。它使“连接钱包”、显示 ENS 和余额信息、签名消息、与合约交互等变得容易。</p>\n<h2>安装</h2>\n<p>安装 <code>@wagmi/core</code> 及 <a href=\"https://viem.sh/\">viem</a> 并列依赖项。</p>\n<pre class=\"prettyprint language-bash\"><code>pnpm i @wagmi&#x2F;core viem\n</code></pre><h2>配置链</h2>\n<p>首先，配置 wagmi 使用的你想要的链，以及你想要使用的 <code>providers</code> 。</p>\n<pre class=\"prettyprint language-ts\"><code>import { configureChains, mainnet } from &#x27;@wagmi&#x2F;core&#x27;\nimport { publicProvider } from &#x27;@wagmi&#x2F;core&#x2F;providers&#x2F;public&#x27;\n\nconst { chains, publicClient, webSocketPublicClient } = configureChains(\n  [mainnet],\n  [publicProvider()],\n)\n</code></pre><p>此示例使用从 <code>@wagmi/core</code> 导入的以太坊主网链(<code>mainnet</code>) ，当然，您也可以传入任何 <a href=\"https://wagmicn.web3hacker.world/core/chains#wagmichains\">EVM 兼容链</a>。</p>\n<p>注意：在生产环境的应用中，不建议仅传递 <code>publicProvider</code> 给 <code>configureChains</code>，因为您可能会面临公共 provider 端点的速率限制。建议也提供一个 <a href=\"https://wagmicn.web3hacker.world/core/providers/alchemy\"><code>alchemyProvider</code></a> 或 <a href=\"https://wagmicn.web3hacker.world/core/providers/infura\"><code>infuraProvider</code></a>。</p>\n<p><a href=\"https://wagmicn.web3hacker.world/core/providers/configuring-chains\">阅读有关配置链的更多信息</a></p>\n<h2>创建 wagmi 配置</h2>\n<p>接下来，使用 <a href=\"https://wagmicn.web3hacker.world/core/config\"><code>createConfig</code></a> 创建一个 wagmi config实例，并将结果通过 <code>configureChains</code> 传递给它。</p>\n<pre class=\"prettyprint language-ts {14-18}\"><code>import {\n  createConfig,\n  configureChains,\n  mainnet,\n} from &#x27;@wagmi&#x2F;core&#x27;\nimport { publicProvider } from &#x27;@wagmi&#x2F;core&#x2F;providers&#x2F;public&#x27;\n\nconst { chains, publicClient, webSocketPublicClient } = configureChains(\n  [mainnet],\n  [publicProvider()],\n)\n\nconst config = createConfig({\n  autoConnect: true,\n  publicClient,\n  webSocketPublicClient,\n})\n</code></pre><p><a href=\"https://wagmicn.web3hacker.world/core/config\">阅读有关客户端配置的更多信息</a></p>\n<h2>你可以开始了</h2>\n<p>使用 <code>action</code> 吧！您现在可以在整个应用程序中导入和使用 <code>action</code>。</p>\n<pre class=\"prettyprint language-ts {4-6,7}\"><code>import { connect, fetchEnsName } from &#x27;@wagmi&#x2F;core&#x27;\nimport { InjectedConnector } from &#x27;@wagmi&#x2F;core&#x2F;connectors&#x2F;injected&#x27;\n\nconst { address } = await connect({\n  connector: new InjectedConnector(),\n})\nconst ensName = await fetchEnsName({ address })\n</code></pre><p>想了解更多？继续阅读文档。</p>\n<blockquote>\n<p>我是来自 <code>Web3Hacker.World</code>的 Bruce，22 年 5 月 All In Web3，后面连续参加了 10 多个黑客松并三个月内拿到 15 个左右的赛道奖及 Grants，累积产值 70 万 RMB 左右（含后续参与其他团队获得）。\n后面又经历休息、搬家到海边（懒散了几个月）、从新学习了大量新技术。现在又开始新的一轮的 Web3 掘金。\n这波主要围绕我创建的 <code>BuidlerProtocol</code> 打造 <code>万物皆可 Web3</code> 的跨链的 <code>Web3 App Store</code> 生态平台来制作各种不同的实际应用场景的 DApp 参加各种不同的黑客松比赛并尝试获得 Web3 投资机构的投资。\n在这个过程中，我会用 Web3 的技术开发一系列产品，并在过程中实际使用他们。比如使用 Web3 的博客平台来分享我们后续的付费阅读的文章 Web3NFT.Social.</p>\n</blockquote>\n<hr>\n<h3>往期回顾</h3>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=Mzk0NDM5NzkwNg==&amp;mid=2247483849&amp;idx=1&amp;sn=18920019b11ce4c61718874266faa9b0&amp;chksm=c3240af4f45383e2ea46f21d3d65d7d47186e74d435878859a9682503d3fffe5bb709bd8976b&amp;token=710208366&amp;lang=zh_CN#rd\">辞职 All in Web3 一年的回顾以及一些对 Web3 NFT 的看法见解 （一）</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=Mzk0NDM5NzkwNg==&amp;mid=2247483881&amp;idx=1&amp;sn=93c85b1d9e8459c4d36f0184b19a5b90&amp;chksm=c3240ad4f45383c287de88ad8247e124572e4c554172e8367eb0140958550052b32348168033&amp;token=710208366&amp;lang=zh_CN#rd\">辞职 All in Web3 一年的回顾以及一些对 Web3 NFT 的看法见解 （二）</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=Mzk0NDM5NzkwNg==&amp;mid=2247483903&amp;idx=1&amp;sn=8f66059eac6de805c7e8340dc322b0a0&amp;chksm=c3240ac2f45383d43d5dea6abe59cfaf302c35a53c51d90d51d2203b2481c1ca2422ce22031e&amp;payreadticket=HK0vH-VgFuwBPr4gN2wYXhvqXGV5ld6kPkiC4AJp1ZdDicfP6ZQzJOMyOJz1AR0qFcEOMzY#rd\">对于 2023 至 2025 年是 Web3 的 iPhone 时刻 文章的一些看法</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=Mzk0NDM5NzkwNg==&amp;mid=2247483903&amp;idx=2&amp;sn=35e4a0c768248644719be77e64432075&amp;chksm=c3240ac2f45383d4ff5bb1caad8636d30836647ca492560b1c2598776bc601dfa7f7b8c6cacb&amp;payreadticket=HDoD_mLn3oAbe1ycn9lkwy8l9ckXsxRtY7u_hTWI6SsrfGXWiMCYYqWdSlGb8p8pwMuQdjg#rd\">申请 Alliance 投资孵化的一些小贴士</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=Mzk0NDM5NzkwNg==&amp;mid=2247483778&amp;idx=1&amp;sn=a43130fe5e9c5132986f892a724040b2&amp;chksm=c3240abff45383a9a14b200503680abfe00ff67eedb62ed8d98aaa99f97264651ba1259a56b5&amp;token=1902673380&amp;lang=zh_CN#rd\">介绍下Web3赏金黑客们必备的开箱即用 Web3 元宇宙 NFT 开发必备脚手架</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=Mzk0NDM5NzkwNg==&amp;mid=2247483715&amp;idx=1&amp;sn=4c39648183b0cb2781819e3a065d0a86&amp;chksm=c3240a7ef45383681fff64cff623ef0a9590abf8f6f31e015975210ebc64d1f1b67f26356fa7&amp;token=1411723489&amp;lang=zh_CN#rd\">一个解决方案来让你的 NFT 拥有无限可能</a></li>\n</ul>\n</div>",
    "title": "Web3开发技术更新： 还在用 web3.js 或 ethers.js? 试试 Wagmi 和 Viem!",
    "last_reply_at": "2023-05-30T23:53:41.014Z",
    "good": false,
    "top": false,
    "reply_count": 0,
    "visit_count": 42,
    "create_at": "2023-05-30T23:53:41.014Z",
    "author": {
      "loginname": "lyman",
      "avatar_url": "//gravatar.com/avatar/f2764a9cb957064880b772775ee93918?size=48"
    }
  },
  {
    "id": "647570c856d98358af9d97d0",
    "author_id": "550973933135610a365b01fa",
    "tab": "share",
    "content": "<div class=\"markdown-text\"><blockquote>\n<p>react 18 新增了启发式的并发渲染机制，副作用函数会因为组件重渲染可能调用多次，为了帮助用户理清正确的副作用使用方式，在开发模式启用StrictMode时，会刻意的故意调用两次副作用函数，来达到走查用户逻辑的效果，但此举也给部分升级用户带来了困扰，本文将讨论helux如何规避此问题。</p>\n</blockquote>\n<h2>helux 简介</h2>\n<p><a href=\"https://github.com/tnfe/hel/tree/main/packages/helux\">helux</a>是一个主打轻量、高性能、0成本接入的react状态库，你的应用仅需替换<code>useState</code>为<code>useShared</code>，然后就可以在其他代码<strong>一行都不用修改</strong>的情况下达到提升react局部状态为全局共享状态的效果，可访问此在线<a href=\"https://codesandbox.io/s/helux-effect-qyv6xz?file=/src/App.tsx\">示例</a>了解更多。</p>\n<pre class=\"prettyprint language-diff\"><code>import React from &#x27;react&#x27;;\n+ import { createShared, useShared } from &#x27;helux&#x27;;\n+ const { state: sharedObj } = createShared({a:100, b:2});\n\nfunction HelloHelux(props: any) {\n-  const [state, setState] = React.useState({ a: 100, b: 2 });\n+  const [state, setState] = useShared(sharedObj);\n\n   &#x2F;&#x2F; 当前组件仅依赖a变更才触发重渲染\n   &#x2F;&#x2F; helux会动态收集当前组件每一轮渲染的最新依赖，以确保做到精确更新\n   return &lt;div&gt;{state.a}&lt;&#x2F;div&gt;;\n}\n</code></pre><p>默认共享对象是非响应的，期望用户按照react的方式去变更状态，如用户设置<code>enableReactive</code>为true后，则可创建响应式对象</p>\n<pre class=\"prettyprint language-ts\"><code>const { state, setState } = createShared({ a: 100, b: 2 }, true);\n&#x2F;&#x2F; or\nconst { state, setState } = createShared({ a: 100, b: 2 }, { enableReactive: true });\n\n&#x2F;&#x2F; 将更新所有使用 &#96;sharedObj.a&#96; 值的组件实例\nsharedObj.a++; \nsetState({a: 1000});\n</code></pre><h2>2.0 带来了什么</h2>\n<p><code>2.0</code>版本做了以下三个调整</p>\n<h3>精简api命名</h3>\n<p>原来的 <code>useSharedObject</code> api重新导出为更精简的<code>useShared</code>，配合<code>createShared</code>以便提高用户的书写效率和阅读体验。</p>\n<h3>新增信号记录（实验中）</h3>\n<p>内部新增了信号相关的记录数据，为将来要发布的<code>helux-signal</code>（一个基于helux封装的react signal模式实现库）做好相关基础建设，<code>helux-signal</code>还在原型阶段，在合适的时机会发布<code>beta</code>版本体验。</p>\n<p>不使用信号时，需要<code>createShared</code> 和 <code>useShared</code> 来两者一起搭配，<code>createShared</code>创建共享状态，<code>useShared</code>负责消费共享状态，它返回具体的可读状态值和更新函数。</p>\n<pre class=\"prettyprint\"><code>const { state: sharedObj } = createShared({a:100, b:2}); &#x2F;&#x2F; 创建\nfunction HelloHelux(props: any) {\n  const [state, setState] = useShared(sharedObj); &#x2F;&#x2F; 使用\n  &#x2F;&#x2F; render logic ...\n}  \n</code></pre><p>使用信号时，仅需要调用<code>helux-signal</code>一个接口<code>createSignal</code>既可以完成状态的创建，然后组件可跳过<code>useShared</code>钩子函数直接读取共享状态。</p>\n<p>需注意，目前helux 2仅是内部完成了相关基础建设，上层负责具体实现的helux-signal还在实验阶段，现阶段社区已有preact提供的<a href=\"https://www.npmjs.com/package/@preact/signals-react\">signals-react</a>库来支持signal模式开发react组件。</p>\n<p>一个预想的完整的基于<code>helux-signal</code>开发react组件示例如下：</p>\n<pre class=\"prettyprint\"><code>import { createSignal, comp } from &#x27;helux-signal&#x27;;\n\nconst { state, setState } = createSignal({a:100, b:2}); &#x2F;&#x2F; 创建信号\n&#x2F;&#x2F; 以下两种方式都将触发组件重渲染\nstate.a++;\nsetState({a: 1000});\n\n&#x2F;&#x2F; &lt;HelloSignal ref={ref} id=&quot;some-id&quot; &#x2F;&gt;\nconst HelloSignal = comp((props, ref)=&gt;{ &#x2F;&#x2F; 创建可读取信号的react组件\n\treturn &lt;div&gt;{state.a}&lt;&#x2F;div&gt;; &#x2F;&#x2F; 当前组件的依赖是 state.a\t\n})\n</code></pre><h3>新增 useEffect、useLayoutEffect</h3>\n<p>v2版本新增了<code>useEffect</code>，<code>useLayoutEffect</code>两个接口，这也是本文要重点讨论的两个接口，为何<code>helux</code>提供这两个接口来替代原生接口呢？且看下面的内容一一详解。</p>\n<h2>react18 的副作用</h2>\n<p>react 18 新增了启发式的并发渲染机制，副作用函数会因为组件重渲染可能调用多次，为了帮助用户发现未正确使用副作用带来的可能问题（例如忘了做清理行为），在开发模式启用StrictMode时，会刻意的故意调用两次副作用函数，来达到走查用户逻辑的效果，期望用户正确的理解副作用函数。</p>\n<p>实际情况什么情况会产生多次挂载行为呢？新文档特意提到了一个例子，由于在18里react会分离组件的状态与卸载行为（非用户代码控制的卸载），即组件卸载了状态依然保持，再次挂载时会由react内部还原回来，例如<strong>离屏渲染</strong>场景需要此特性。</p>\n<h3>双调用的困扰</h3>\n<p>但此举也给部分升级用户带来了困扰，以下面例子为例：</p>\n<pre class=\"prettyprint language-ts\"><code>function UI(props: any) {\n  useEffect(() =&gt; {\n    console.log(&quot;mount&quot;);\n    return () =&gt; {\n      console.log(&quot;clean up&quot;);\n    };\n  }, []);\n}\n</code></pre><p>在 strcit 模式打印如下</p>\n<pre class=\"prettyprint language-txt\"><code>mount\nclean up\nmount\n</code></pre><p>用户真正卸载组件后还有一次<code>clean up</code>打印，由此让很多用户误以为是bug，去react仓库提issue描述升级18后useEffect产生了两次调用，后来react官方专门解释了此问题是正常现象，为辅助用户存在不合理的副作用函数刻意做的双调用机制。</p>\n<p>但有些场景用户的确期望开发时也只产生一次调用（例如组件的数据初始化），于是就有了以下各种花式对抗双调用的方式。</p>\n<h3>移除 StrcitMode</h3>\n<p>最简单粗暴的方式，就是移除根组件处的<code>StrcitMode</code>包裹，彻底屏蔽此双调用行为。</p>\n<pre class=\"prettyprint language-diff\"><code>root.render(\n-  &lt;React.StrictMode&gt;\n    &lt;App &#x2F;&gt;\n-  &lt;&#x2F;React.StrictMode&gt;\n);\n</code></pre><p>用户可能只需要某些地方无双调用，其他地方需要双调用检查副作用的正确性的话，但此举属于一杆子打死所有场景行为，不太通用。</p>\n<h3>局部包裹StrcitMode</h3>\n<p><code>StrcitMode</code>除了包裹根组件，也支持包裹任意子组件，用户可以在需要的地方包裹</p>\n<pre class=\"prettyprint language-tsx\"><code> &lt;React.StrictMode&gt;&lt;YourComponent &#x2F;&gt;&lt;&#x2F;React.StrictMode&gt;\n</code></pre><p>相比全局移除，此方法较为温和，但包裹StrictMode是一个强迫性的行为，需要代码处导出安排哪里需要包裹那里不需要包裹，较为麻烦，有没有既能在根组件包裹<code>StrcitMode</code>又能局部屏蔽双调用机制的方式呢？用户们开始从代码层面入手，准确的说是<code>useEffect</code>回调里入手</p>\n<h3>使用useRef标记执行状态</h3>\n<p>大体思路是使用<code>useRef</code>记录一个副作用函数是否已执行的状态，让第二次调用被忽略。</p>\n<pre class=\"prettyprint\"><code>function Demo(props: any) {\n  const isCalled = React.useRef(false);\n\n  React.useEffect(() =&gt; {\n    if (isCalled.current === false) {\n      await somApi.fetchData();\n      isCalled.current = true;\n    }\n  }, []);\n}\n</code></pre><p>此举有一定的局限性，就是如果加上依赖后，<code>isCalled</code>无法控制，按思维会副作用清理函数里置<code>isCalled.current</code>为false，这样在组件的存在期过程中变更id值时，尽管有双调用行为也不会打印两次<code>mock api fetch</code></p>\n<pre class=\"prettyprint\"><code> React.useEffect(() =&gt; {\n    if (isCalled.current === false) {\n\t    isCalled.current = true;\n      console.log(&#x27;mock api fetch&#x27;);\n\t    return ()=&gt;{\n\t\t isCalled.current = false;\n\t\t console.log(&#x27;clean up&#x27;);\n\t    };\n    }\n  }, [id]); &#x2F;&#x2F; id 变更时，发起新的请求\n</code></pre><p>但如上写法，在组件首次挂载时还是发生两次调用，打印顺序为</p>\n<pre class=\"prettyprint language-txt\"><code>mock api fetch\nclean up\nmock api fetch\n</code></pre><p>有没有真正的完美方案，让基于根组件包裹<code>StricMode</code>时，子组件初次挂载和存在期始终副作用只发生一次调用呢？接下来让<code>helux</code>提供的<code>useEffect</code>来彻底解决此问题吧</p>\n<h3>使用helux的useEffect</h3>\n<p>我们只要核心理解react双调用的原由：让组件卸载和状态分离，即组件再次挂载时存在期的已有状态会被<strong>还原</strong>，既然有一个还原的过程，那么入手点就很容易了，主要就是观察在组件还原那一刻的运行日志来查找规律。</p>\n<p>先标记一个序列自增id当做组件示例id，观察挂载行为针对是哪一个实例</p>\n<pre class=\"prettyprint\"><code>let insKey = 0;\nfunction getInsKey() {\n  insKey++;\n  return insKey;\n}\n\nfunction TestDoubleMount() {\n  const [insKey] = useState(() =&gt; getInsKey());\n  console.log(&#96;TestDoubleMount ${insKey}&#96;);\n  React.useEffect(() =&gt; {\n    console.log(&#96;mount ${insKey}&#96;);\n    return () =&gt; console.log(&#96;clean up ${insKey}&#96;);\n  }, [insKey]);\n  return &lt;div&gt;TestDoubleMount&lt;&#x2F;div&gt;;\n}\n</code></pre><p>可观察到日志如下图，可发现灰色的打印 <code>TestDoubleMount</code> 是react故意发起的第二次调用，副作用都是针对2号示例，1号作为一次冗余的调用被react丢弃掉。</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8a615694b11f479b9dd692940d6aeced~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\"></p>\n<p>由于id是自增的，react会刻意的对同一个组件发起两次调用，丢弃第一个并针对第二个调用重复执行副作用（mount–&gt;clean–&gt;mount —&gt; 组件卸载后 clean），那么我们在第二个副作用执行时只要检查前一个示例是否存在副作用记录，同时记录第二个副作用的执行次数，就很容易做到屏蔽第二次模式出的副作用了，即（mount–&gt;clean–&gt;mount —&gt; 组件卸载后 clean）被修改为（mount —&gt; 组件卸载后 clean），在组件真正执行卸载时执行设定的clean。</p>\n<p>伪代码如下</p>\n<pre class=\"prettyprint language-ts\"><code>function mayExecuteCb(insKey: number, cb: EffectCb) {\n  markKeyMount(insKey); &#x2F;&#x2F; 记录当前实例id 挂载次数\n  const curKeyMount = getKeyMount(insKey); &#x2F;&#x2F; 获取当前实例挂载信息\n  const pervKeyMount = getKeyMount(insKey - 1); &#x2F;&#x2F; 获取前一个实例的挂载信息\n  if (!pervKeyMount) { &#x2F;&#x2F; 前一个示例无挂载信息则是双调用行为\n    if (curKeyMount &amp;&amp; curKeyMount.count &gt; 1) { &#x2F;&#x2F; 当前实例第二次挂载才正在执行用户的副作用函数\n      const cleanUp = cb();\n      return () =&gt; {\n        clearKeyMount(insKey); &#x2F;&#x2F; 清理当前实例挂载信息\n        cleanUp &amp;&amp; cleanUp(); &#x2F;&#x2F; 返回清理函数\n      };\n    }\n  }\n}\n</code></pre><p>在此基础上封装一个<code>useEffect</code>给用户即可达到我们上面说的目的：让基于根组件包裹<code>StricMode</code>时，子组件初次挂载和存在期始终副作用只发生一次调用。</p>\n<pre class=\"prettyprint\"><code>function useEffect(cb: EffectCb, deps?: any[]) {\n  const [insKey] = useState(() =&gt; getInsKey()); &#x2F;&#x2F; 写为函数避免key自增开销\n  React.useEffect(() =&gt; {\n    return mayExecuteCb(insKey, cb);\n  }, deps);\n}\n</code></pre><p>如果感兴趣<code>useEffect</code>的具体实现可查看仓库<a href=\"https://github.com/tnfe/hel/blob/main/packages/helux/src/hooks/useEffect.ts\">代码</a></p>\n<p>现在你可以像使用原生的<code>useEffect</code>那样使用<code>helux</code>导出的<code>useEffect</code>，同时享受到某些场景不需要双调用检测的好处了。</p>\n<pre class=\"prettyprint language-ts\"><code>import { useEffect } from &#x27;helux&#x27;;\n\nuseEffect(() =&gt; {\n  console.log(&#x27;mock api fetch&#x27;, id);\n  return () =&gt; {\n    console.log(&#x27;mock clean up&#x27;);\n  };\n}, [id]); &#x2F;&#x2F; id 变更时，发起新的请求\n</code></pre><h3>结语</h3>\n<p>了解<code>双调用</code>的设计初衷与流程有助于帮助我们更清晰的理解副作用函数如何治理，同时也可以帮助我们为避免双调用机制做出更好的决策。</p>\n<p><a href=\"https://github.com/tnfe/hel/blob/main/packages/helux\">helux</a>属于模块联邦sdk <a href=\"https://github.com/tnfe/hel\">hel-micro</a>子包，初衷是为 react 提供一种更灵活、更低廉成本的状态共享方式，如果你对helux或hel-micro感兴趣，欢迎关注并给予我们更多的改进反馈意见。</p>\n</div>",
    "title": "helux 2 发布，助你深度了解副作用的双调用机制",
    "last_reply_at": "2023-05-30T03:43:04.942Z",
    "good": false,
    "top": false,
    "reply_count": 0,
    "visit_count": 62,
    "create_at": "2023-05-30T03:43:04.942Z",
    "author": {
      "loginname": "fantasticsoul",
      "avatar_url": "https://avatars.githubusercontent.com/u/7334950?v=4&s=120"
    }
  },
  {
    "id": "643792746779ea384914db2f",
    "author_id": "60460ff34655eaadc021a4db",
    "tab": "share",
    "content": "<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/Fg5rNitzL2mSiYAzDadW9o9XIvTy\" alt=\"index.JPG\">\n<em>首页 (引入侧边栏，全局显示用户的歌单列表)</em></p>\n<p><img src=\"//static.cnodejs.org/Fg3V7-Y2Zr6MBKD_t0WG1kIic-6I\" alt=\"搜索薛之谦.JPG\">\n<em>搜索&quot;薛之谦&quot;</em></p>\n<p><img src=\"//static.cnodejs.org/Fk9wkSI6nS73Jo4jwfjaorlGqy7h\" alt=\"搜索巴赫旧约.JPG\">\n<em>搜索&quot;巴赫旧约&quot;</em></p>\n<p><img src=\"//static.cnodejs.org/FnJo-Q2Yp71yR7fmmBtqxx5F0paD\" alt=\"导入狂飙.JPG\">\n<em>导入专辑 《狂飙》OST</em></p>\n<p><img src=\"//static.cnodejs.org/FkcB-uAPkV_FE8Dy6ZiVAn1507WW\" alt=\"歌词_播放列表.JPG\">\n<em>歌词 &amp; 播放列表</em></p>\n<p><img src=\"//static.cnodejs.org/FonR7rUdeZAlmb90OQdarKF2Ii-8\" alt=\"artists.png\">\n<em>Artists</em></p>\n<p><strong><a href=\"https://tonzhon.com\">https://tonzhon.com</a></strong>\nGitHub: <a href=\"https://github.com/enzeberg/tonzhon-music\">https://github.com/enzeberg/tonzhon-music</a></p>\n<p>这个音乐 Web App 现在用上了 <strong>侧边栏</strong>，专门显示用户的歌单列表，并使其保持全局显示，从而强调用户自身的重要性，弱化环境的重要性。“一切以用户为中心”是它的宗旨。</p>\n<p>它还把灰色背景改成了白色，把白色卡片改成了灰色线框 (有些左侧边框用上了其他颜色，便于用户区分不同的卡片)…</p>\n<p>期待大家的建议~</p>\n</div>",
    "title": "这个可以免费听歌的 web app，上线了全新的 UI 和 功能...",
    "last_reply_at": "2023-05-30T03:31:48.145Z",
    "good": false,
    "top": false,
    "reply_count": 7,
    "visit_count": 2273,
    "create_at": "2023-04-13T05:26:12.759Z",
    "author": {
      "loginname": "enzeberg",
      "avatar_url": "https://avatars.githubusercontent.com/u/18072932?v=4&s=120"
    }
  },
  {
    "id": "646df87a267193300c5b8179",
    "author_id": "5836b3846add41f206000bf0",
    "tab": "ask",
    "content": "<div class=\"markdown-text\"><p>打扰了，更新prisma后，无法下载prisma包\n在Prisma@4.14.1中，报not found</p>\n<pre class=\"prettyprint\"><code>Downloading Prisma engines for Node-API for rhel-openssl-1.0.x [                    ] 0%\nError: Not Found https:&#x2F;&#x2F;registry.npmmirror.com&#x2F;-&#x2F;binary&#x2F;prisma&#x2F;all_commits&#x2F;d9a4c5988f480fa576d43970d5a23641aa77bc9c&#x2F;rhel-openssl-1.0.x&#x2F;libquery_engine.so.node.gz\n</code></pre><p>prisma engine下载类型\nschema.prisma</p>\n<pre class=\"prettyprint\"><code>generator client {\n  provider      = &quot;prisma-client-js&quot;\n  output        = &quot;.&#x2F;generated&#x2F;prisma-client-js&quot;\n  binaryTargets = [&quot;rhel-openssl-1.0.x&quot;]\n}\n</code></pre><p>环境变量</p>\n<pre class=\"prettyprint\"><code>PRISMA_ENGINES_MIRROR=https:&#x2F;&#x2F;registry.npmmirror.com&#x2F;-&#x2F;binary&#x2F;prisma\n</code></pre><p>如果移除这个变量，换成默认<code>https://binaries.prisma.sh</code>则正常，但是这个源被block，你懂得。\n但是 Prisma@4.13.0 版本正常，应该是npmirror同步问题，如何解决？</p>\n<p>相关问题：\n<a href=\"https://github.com/cnpm/mirrors/issues/248\">https://github.com/cnpm/mirrors/issues/248</a>\n<a href=\"https://github.com/prisma/prisma/issues/12662\">https://github.com/prisma/prisma/issues/12662</a></p>\n</div>",
    "title": "【求助】Prisma@4.14.1在npmmirror上无法下载",
    "last_reply_at": "2023-05-30T02:58:28.913Z",
    "good": false,
    "top": false,
    "reply_count": 2,
    "visit_count": 413,
    "create_at": "2023-05-24T11:43:54.470Z",
    "author": {
      "loginname": "victoryboss",
      "avatar_url": "https://avatars.githubusercontent.com/u/5610115?v=4&s=120"
    }
  },
  {
    "id": "646b2f9726719373205b7fa7",
    "author_id": "5ad9b2a3ba60fcc66b7b86ea",
    "tab": "share",
    "content": "<div class=\"markdown-text\"><p>应用内提供了付费免 Key 免梯子，如果有自己的 Key 的话也可以用自己的~\n<img src=\"https://moss.csxq.fun/assets/home-stack-33a12395.png\" alt>\n个人感觉还是很好用的，尤其是小窗和命令面板</p>\n<p>小窗可以在任意位置打开，可以钉在桌面上，交互很流畅\n<img src=\"https://moss.csxq.fun/assets/mini-3c52c0b8.png\" alt>\n命令面板可以搜索历史消息和会话\n<img src=\"https://moss.csxq.fun/assets/commandPanel-f66b2cbc.png\" alt>\n还有消息模板、AI 工具箱这些功能\n<img src=\"https://moss.csxq.fun/assets/aiTools-0cf68cf1.png\" alt>\n<img src=\"https://moss.csxq.fun/assets/template-459678e2.png\" alt>\n我也在持续更新应用功能，欢迎大家下载体验！！！\n下载地址：<a href=\"https://mossgpt.fun\">https://mossgpt.fun</a></p>\n</div>",
    "title": "做了一款桌面端的 ChatGPT 客户端，欢迎大家来体验体验~",
    "last_reply_at": "2023-05-29T11:02:38.122Z",
    "good": false,
    "top": false,
    "reply_count": 1,
    "visit_count": 656,
    "create_at": "2023-05-22T09:02:15.499Z",
    "author": {
      "loginname": "lblblong",
      "avatar_url": "https://avatars.githubusercontent.com/u/18625523?v=4&s=120"
    }
  },
  {
    "id": "6474744356d98380669d9712",
    "author_id": "5186db7e6d382773067251ce",
    "tab": "share",
    "content": "<div class=\"markdown-text\"><blockquote>\n<p>Web3Hacker.World 是一个集合程序员黑客、对新事物好奇的种子用户、及 vc 投资者组合的围绕 <code>万物皆可 Web3</code> 的理念打造的生态体系，目前已有付费会员 19 人</p>\n</blockquote>\n<blockquote>\n<p>我是来自 <code>Web3Hacker.World</code>的 Bruce，22 年 5 月 All In Web3，后面连续参加了 10 多个黑客松并三个月内拿到 15 个左右的赛道奖及 Grants，累积产值 70 万 RMB 左右（含后续参与其他团队获得）。\n后面又经历休息、搬家到海边（懒散了几个月）、从新学习了大量新技术。现在又开始新的一轮的 Web3 掘金。\n这波主要围绕我创建的 <code>BuidlerProtocol</code> 打造 <code>万物皆可 Web3</code> 的跨链的 <code>Web3 App Store</code> 生态平台来制作各种不同的实际 RWA(Real World Assets) 应用场景的 DApp 参加各种不同的黑客松比赛并尝试获得 RWA 的早期种子用户。\n在这个过程中，我会用 Web3 的技术开发一系列产品，同步输出开发这些产品的一些相关技术资料总结及分享。</p>\n</blockquote>\n<p>本周开始报名了波卡黑客松比赛，这次规划做一个 NFT-Fi-Twitter  的浏览器插件，可以让 Twitter 用户去发布 NFT-Gating 的 twitter 或者评论，而要查看加密的内容的用户则需要支付 $BST 才能解锁（付费解锁时会附带获得对应的 NFT 作为支付凭证），在做的过程中延伸出了一系列的技术扩展需要研究。</p>\n<h2>TL;DR</h2>\n<ul>\n<li>NFT-Fi-Twitter: 可以注入到各种页面的 BuidlerProtocol 应用钱包\n<ul>\n<li>content inject 部分：在页面注入了内容数据列表及新建内容表单</li>\n<li>options: 一整个 onboard 模块的 UI 设置好了，为了实现钱包的秘钥保存功能，翻译了 <a href=\"https://www.wispwisp.com/index.php/2020/12/25/how-metamask-stores-your-wallet-secret/\">MetaMask 是怎么保存你的钱包秘钥的？</a> 这篇文章，不过作者其实也是国人，只是用英文写的文章</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/Web3Hacker-World/Discussions/issues/17\">vue3-wagmi</a> 欢迎对开发 vue生态的 Web3 组件的同学加入报名，后续 Web3Hacker.World 会陆续推出激励机制</li>\n<li><a href=\"https://github.com/Web3Hacker-World/Discussions/issues/18\">wagmi-cn</a> 将组织翻译 wagmi 及 viem 文档中和 react 无关的部分（即通用部分）</li>\n</ul>\n<h2>细节版本</h2>\n<ul>\n<li>浏览器插件开发相关技术: <a href=\"https://plasmo.com/\">Plasmo</a> / <a href=\"https://github.com/antfu/vitesse-webext\">vitesse-webext</a>\n<ul>\n<li>Plasmo\n<ul>\n<li>这个技术去年就有关注，不过一直没有实战，这次立项 NFT-Fi-Twitter 浏览器扩展一开始也重新翻了一波他的文档及示例代码，但最终没有选择使用。</li>\n<li>因为使用 vue 技术栈，虽然里面也有 vue 的示例代码，但是实际大规模的工程化开发还需要很多的配置和模块化设计</li>\n<li>虽然开源，但是很多底层的配置我还没有看到可以自由设置，有点感觉被捆绑住了，要修改个 vite 配置等还得去翻额外文档或者代码</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>最终使用了 <a href=\"https://github.com/antfu/vitesse-webext\">vitesse-webext</a></li>\n<li>这个是 <a href=\"https://github.com/antfu/vitesse\">vitesse</a> 的变种</li>\n<li>虽然他已有的代码逻辑并没有完全设计好大规模工程化开放的架构设计，但是我们可以比较自由的去修改底层一些设置</li>\n<li>我们本身之前的 Craft V1 及去年的 web3-framework 其实都是在其基础上进一步开发产生的</li>\n<li>目前我们的 Craft V2 即 Nuxt3 版本也是在其 Nuxt 变种基础上加上了额外设计架构成为 layer 模式继承开发的</li>\n<li>这些各种变种的设计思路都是一样的，打造统一的一致的能简化程序员开发心智的代码架构设计</li>\n<li>这一系列其实大部分套件都一样\n<ul>\n<li>Vue3, Vite, pnpm, esbuild</li>\n<li>文件基础的路由\n<ul>\n<li>在 webext 版本中其并不支持，我们在这周也改造好了, 设计了 options/popup 的路由前缀</li>\n</ul>\n</li>\n<li>组件自动导入</li>\n<li>通过 Pinia 进行状态管理\n<ul>\n<li>webext 版本还未使用 Pinia</li>\n</ul>\n</li>\n<li>Layout 系统\n<ul>\n<li>webext 版本中原本也不支持，我们本周也实现了</li>\n</ul>\n</li>\n<li>UnoCSS</li>\n<li>无需导入即可快速使用各种 Icon</li>\n</ul>\n</li>\n<li>我们额外根据 Web3 开发的需求进行了进一步改造\n<ul>\n<li>引入使用 <a href=\"https://wagmi.sh/core/getting-started\">Wagmi</a> 4.5k star\n<ul>\n<li>其初始定位为以太坊的 React Hooks（不过 EVM 兼容的均可）</li>\n<li>后面其抽象除了一套 ts 原生的 api，故我们可以在此基础上去封装一套 vue 的 composables api\n<ul>\n<li>在其 <a href=\"https://github.com/wagmi-dev/awesome-wagmi\">awesome</a> 库中看到已经个项目在做了\n<ul>\n<li>一个 <a href=\"https://vagmi.vercel.app/\">vagmi</a>，但是作者竟然<a href=\"https://github.com/wobsoriano/vagmi/issues/60\">弃坑了</a>\n<ul>\n<li>估计用 Vue 开发 Web3 的比较少，用户少这个哥们受不了寂寞就弃坑了（还有他是说他也不再做 Web3 开发了）</li>\n<li>感觉在软件开源层面需要有一个非庞氏的Web3 激励措施来促进代码工具的迭代开发，但是核心还是作者本身有这个热情以及一定的后台支持才好推进，光用爱发电是无法长期维持的</li>\n</ul>\n</li>\n<li>市面上其实还有别的 vue 的栈在做，但是不是很活跃</li>\n</ul>\n</li>\n<li>Web3Hacker.World 在上周也开坑了，不过还没有推代码： <a href=\"https://github.com/Web3Hacker-World/Discussions/issues/17\">https://github.com/Web3Hacker-World/Discussions/issues/17</a>，欢迎 vue3 技术栈同学可以到帖子里报名加入</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>ethersjs 替换为 <a href=\"https://viem.sh/\">Viem</a>\n<ul>\n<li>Wagmi 和 Viem 为同一个团队开发的，这个团队非常活跃，Wagmmi 是其 16 个月前开始的项目 <a href=\"https://twitter.com/wagmi_sh/status/1655993650621317149\">https://twitter.com/wagmi_sh/status/1655993650621317149</a></li>\n<li>而其这次则是在过去 16 个月的密集开发基础上，额外抽象出来 <a href=\"https://viem.sh/\">Viem</a>, 用于取代 ethers.js</li>\n<li>我们这周也花了大量时间深入研究了一波，并会后续开坑组织翻译 Wagmmi 和 Viem 的中文文档，这些资料都会最终放到 BuidlerProtocol 上以 Web3 的 NFT-Gating 的模式提供给我们的黑客会员使用</li>\n<li>感兴趣同学欢迎报名：<a href=\"https://github.com/Web3Hacker-World/Discussions/issues/18\">https://github.com/Web3Hacker-World/Discussions/issues/18</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>原文链接： <a href=\"https://www.wispwisp.com/index.php/2020/12/25/how-metamask-stores-your-wallet-secret/\">https://www.wispwisp.com/index.php/2020/12/25/how-metamask-stores-your-wallet-secret/</a></p>\n<p>作为区块链领域的安全工程师/渗透测试人员，我在研究和客户参与期间测试了许多加密钱包应用程序。在看到在不同钱包中处理秘密的不同方式后，我很好奇 MetaMask（该领域最著名的加密钱包之一）是如何做到的。好吧，如果你问我为什么不早点看 MetaMask，因为我只是假设它是安全的，而且我发现任何问题的机会非常低。</p>\n<p>他们的<a href=\"https://github.com/MetaMask/metamask-extension\">扩展</a>和<a href=\"https://github.com/MetaMask/metamask-mobile\">移动应用程序</a>以及应用程序中使用的由 MetaMask 创建的许多其他模块都是开源的。代码库是迄今为止我见过的所有加密钱包中最大的。但它并不难理解，因为代码写得很好并且有很多注释。</p>\n<p>这篇文章解释了应用程序中与秘钥存储相关的不同组件。在文章的最后，我包含了一个非常粗略的代码逻辑，描述了这个浏览器扩展是怎么创建一个新钱包。请注意，本文中的钱包秘钥指的是助记词(mnemonic)和私钥。</p>\n<h2>秘钥环(Keyring)</h2>\n<p>Keyring是 MetaMask 中秘密存储和账户管理系统的核心概念。<a href=\"https://github.com/MetaMask/KeyringController\">KeyringController</a>是密钥环的实现。引用自 KeyringController README：</p>\n<blockquote>\n<p>一个用于管理以太坊账户组的模块，称为“Keyrings”，最初是为 MetaMask 的多账户类型功能定义的。</p>\n<p>KeyringController 具有三个主要职责：</p>\n<ul>\n<li>初始化和使用（签名）以太坊帐户组（“密钥环”）。</li>\n<li>跟踪这些个人帐户的本地昵称。</li>\n<li>提供密码加密保存和恢复秘密信息。</li>\n</ul>\n</blockquote>\n<p>这是密钥环结构的可视化参考：\n<img src=\"https://github.com/Web3Hacker-World/Discussions/assets/109504677/458a5a89-decd-44da-bc21-8f5958455cdd\" alt=\"keyrings-ref\"></p>\n<p>圆环表示用于生成公钥-私钥对的助记词。挂在环上的每把钥匙就是一个个人钱包帐户，这些私钥都是通过这个助记词生成的。种子短语和所有帐户数据捆绑在一起，使用从用户密码生成的加密密钥加密，并存储在扩展中。</p>\n<p>KeyringController 使用 <code>obs-store</code> 类来存储数据。<code>obs-store</code> 代表 ObservableStore，它是单个值的同步内存存储。该代码还将 obs-store 引用为 <code>Vault</code>。让我们仔细看看它是如何实现的：在 KeyringController 构造函数中创建了两个 <code>ObservableStore</code> 对象，一个名为 <code>this.store</code>，另一个名为 <code>this.memStore</code>：</p>\n<pre class=\"prettyprint language-js{5,6}\"><code>constructor (opts) {\n  super()\n  const initState = opts.initState || {}\n  this.keyringTypes = opts.keyringTypes ? keyringTypes.concat(opts.keyringTypes) : keyringTypes\n  this.store = new ObservableStore(initState)\n  this.memStore = new ObservableStore({\n    isUnlocked: false,\n    keyringTypes: this.keyringTypes.map((krt) =&gt; krt.type),\n    keyrings: [],\n  })\n\n  this.encryptor = opts.encryptor || encryptor\n  this.keyrings = []\n}\n</code></pre><p><code>this.store</code> 存储加密后的钱包秘钥。<code>this.store</code> 的数据会被放入chrome扩展的本地存储中进行持久化数据存储。用户可以通过在扩展开发控制台中输入以下代码来访问数据。（似乎不行，译者注）</p>\n<pre class=\"prettyprint language-js\"><code>chrome.storage.local.get(&#x27;data&#x27;, result =&gt; {\n    var vault = result.data.KeyringController.vault\n    console.log(vault)\n})\n</code></pre><p><img src=\"https://github.com/Web3Hacker-World/Discussions/assets/109504677/0c1a2dfa-a128-423e-b7a6-b2872040168a\" alt=\"this store\"></p>\n<p>而 <code>this.memStore</code> 则是存储解密后的钱包秘钥。该对象中的数据保留在内存中，不会放入浏览器的持久存储中。当您打开 MetaMask 扩展程序并输入您的密码时，您解密后的帐户私钥将存储在这个 <code>this.memStore</code> 对象中以备将来使用。 <a href=\"https://github.com/MetaMask/KeyringController/blob/1a0dbbaf45e54e7b80200d4a9c6b21ce74b61b2f/index.js#L143\">参考代码 1</a>, <a href=\"https://github.com/MetaMask/KeyringController/blob/1a0dbbaf45e54e7b80200d4a9c6b21ce74b61b2f/index.js#L732\">参考代码 2</a></p>\n<h2>加密器(encryptor)</h2>\n<p>在 KeyringController 类内部，加密和解密操作由<a href=\"https://github.com/MetaMask/KeyringController/blob/1a0dbbaf45e54e7b80200d4a9c6b21ce74b61b2f/index.js#L37\">加密器</a> 对象执行。</p>\n<blockquote>\n<p>例子 1. 加密秘钥环数据：</p>\n<pre class=\"prettyprint language-js\"><code>return this.encryptor.encrypt(this.password, serializedKeyrings)\n</code></pre><p>例子 2. 解密此加密保险库</p>\n<pre class=\"prettyprint language-js\"><code>const vault = await this.encryptor.decrypt(password, encryptedVault)\n</code></pre></blockquote>\n<p>加密器对象在 KeyringController 构造函数中分配</p>\n<pre class=\"prettyprint language-js{14}\"><code>constructor (opts) {\n  super()\n  const initState = opts.initState || {}\n  this.keyringTypes = opts.keyringTypes ? keyringTypes.concat(opts.keyringTypes) : keyringTypes\n  this.store = new ObservableStore(initState)\n  this.memStore = new ObservableStore({\n    isUnlocked: false,\n    keyringTypes: this.keyringTypes.map((krt) =&gt; krt.type),\n    keyrings: [],\n  })\n\n  this.encryptor = opts.encryptor || encryptor\n  this.keyrings = []\n}\n</code></pre><p>扩展程序和移动应用程序使用不同的加密器。该扩展使用 <a href=\"https://www.npmjs.com/package/browser-passworder\">browser-passworder</a>模块，其源代码可在 <a href=\"https://github.com/danfinlay/browser-passworder\">Github</a> 上获得。移动应用程序有自己的 <a href=\"https://github.com/MetaMask/metamask-mobile/blob/develop/app/core/Encryptor.js\">加密器</a> 类。它们的工作原理几乎相同，除了[PBKDF2](<a href=\"https://en.wikipedia.org/wiki/PBKDF2%EF%BC%89%E8%BF%AD%E4%BB%A3%E5%92%8C\">https://en.wikipedia.org/wiki/PBKDF2）迭代和</a> <a href=\"https://en.wikipedia.org/wiki/Advanced_Encryption_Standard\">AES</a> 模式。</p>\n<blockquote>\n<p>browser-passworder:\n根据 password 生成 enc_key: PBKDF2, 10000 iteration\nAES mode: AES-GCM</p>\n<p>Mobile app encryptor:\n根据 password 生成 enc_key: PBKDF2, 5000 iteration\nAES mode: AES-CBC</p>\n</blockquote>\n<h2>移动应用</h2>\n<p>与扩展类似，移动应用程序采用密钥环结构来存储秘钥和管理帐户。对于持久存储，应用程序使用 <a href=\"https://github.com/MetaMask/metamask-mobile/blob/efc39fb6c794fe574fcf33fc2f71b2a069ecc4e7/app/store/index.js#L44\">persistConfig</a> 文件中定义的 <a href=\"https://github.com/react-native-async-storage/async-storage\">async-storage</a> 模块存储加密数据。我能找到的唯一描述 <code>异步存储</code> 工作原理的<a href=\"https://reactnative.dev/docs/asyncstorage\">官方文档</a>是这样说的：</p>\n<blockquote>\n<p>在 iOS 上，AsyncStorage 由本机代码支持，该代码将小值存储在序列化字典中，将较大值存储在单独的文件中。</p>\n<p>在 Android 上，AsyncStorage 将根据可用情况使用 RocksDB 或 SQLite。</p>\n</blockquote>\n<p>移动钱包提供 <code>记住我</code> 和 <code>使用触摸 ID/设备密码解锁</code> 选项。用户无需每次在移动设备上打开应用程序时都输入密码。</p>\n<p><img src=\"https://github.com/Web3Hacker-World/Discussions/assets/109504677/437081bc-755f-432a-9c47-4096f0876c82\" alt=\"remember-me\"></p>\n<p><img src=\"https://github.com/Web3Hacker-World/Discussions/assets/109504677/7d99e2e1-efe2-489f-856f-10b9a4f0be49\" alt=\"touchid-passcode\"></p>\n<p>为实现这一点，MetaMask 移动应用程序使用 <a href=\"https://github.com/MetaMask/metamask-mobile/blob/efc39fb6c794fe574fcf33fc2f71b2a069ecc4e7/app/core/SecureKeychain.js#L32\">SecureKeychain</a> 模块将用户密码存储在设备中，该模块建立在 <a href=\"https://github.com/oblador/react-native-keychain\"><code>react-native-keychain</code></a> 之上。用户密码用于生成密钥来解密持久存储中的加密钱包秘密。</p>\n<p>关于 <code>react-native-keychain</code> 如何在移动设备中存储数据的快速说明：</p>\n<ul>\n<li>iOS：将数据存储在 <a href=\"https://developer.apple.com/documentation/security/keychain_services\">iOS Keychain</a> 中</li>\n<li>Android：使用 <a href=\"https://developer.android.com/training/articles/keystore\">Android Keystore</a> 加密数据，将加密数据存储在 SharedPreferences</li>\n</ul>\n<h2><a href=\"https://github.com/MetaMask/metamask-mobile/blob/efc39fb6c794fe574fcf33fc2f71b2a069ecc4e7/app/core/SecureKeychain.js#L32\">安全钥匙串(SecureKeyChain)</a></h2>\n<p>代码中的注释解释了 SecureKeychain 的作用：</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;**\n* react-native-keychain 内包裹 Keychain 的类\n* 抽象 metamask 特定的功能及设置\n* 同时在写入手机的 keychain 前添加额外的层\n*&#x2F;\nclass SecureKeychain {\n...\n}\n</code></pre><p><code>抽象 metamask 特定的功能及设置</code> 是指 <code>记住我</code> 和 <code>使用触摸 ID/设备密码登录</code> 功能。查看 <code>resetGenericPassword</code>,<code>getGenericPassword</code> 和 <code>setGenericPassword</code> 函数以了解它是如何实现的。</p>\n<p>至于“增加一层额外的加密”，我很好奇这里使用的加密密钥是什么来执行加密？这是我找到的相关代码路径：</p>\n<ol>\n<li>构造函数中的 <code>code</code> 用作加密密钥。（<a href=\"https://github.com/MetaMask/metamask-mobile/blob/efc39fb6c794fe574fcf33fc2f71b2a069ecc4e7/app/core/SecureKeychain.js#L35\">来源</a>）</li>\n<li>在 <code>init(salt)</code> 函数中，使用参数 <code>salt</code> 创建 SecureKeychain 对象（<a href=\"https://github.com/MetaMask/metamask-mobile/blob/efc39fb6c794fe574fcf33fc2f71b2a069ecc4e7/app/core/SecureKeychain.js#L54\">来源</a>）</li>\n<li><code>init</code> 使用参数 <code>props.foxCode( Source )</code> 调用该函数（<a href=\"https://github.com/MetaMask/metamask-mobile/blob/efc39fb6c794fe574fcf33fc2f71b2a069ecc4e7/app/components/Views/Root/index.js#L34\">来源</a>）</li>\n</ol>\n<p><code>foxCode</code> 又是什么？我在 <a href=\"https://github.com/MetaMask/metamask-mobile\">手机钱包仓库</a> 和 <a href=\"https://github.com/MetaMask\">MetaMask 组织</a> 下的所有公共仓库中搜索 ，但没有结果。嗯🤔，应用程序二进制文件怎么样？</p>\n<p>我用这个<a href=\"https://apps.evozi.com/apk-downloader/\">工具</a>下载了 <a href=\"https://play.google.com/store/apps/details?id=io.metamask&amp;hl=en_US&amp;gl=US\">Metamask APK</a> ，用 <a href=\"https://github.com/skylot/jadx\">jadx</a> 解包，搜索字符串 <code>foxCode</code>，发现了这个：</p>\n<p>&lt;img width=“750” alt=“foxcode” src=“<a href=\"https://github.com/Web3Hacker-World/Discussions/assets/109504677/1210ff50-fc8e-4c31-978d-7d305f58797c\">https://github.com/Web3Hacker-World/Discussions/assets/109504677/1210ff50-fc8e-4c31-978d-7d305f58797c</a>”&gt;</p>\n<p>等等，所以foxCode等于字符串“encrypt”？使用硬编码字符串加密某些内容有什么意义？🤔</p>\n<p>我给 Metamask 安全团队发了一封邮件，询问为什么用硬编码字符串（foxCode）<code>encrypt</code> 加密的用户密码，该团队回复说：</p>\n<p><img src=\"https://github.com/Web3Hacker-World/Discussions/assets/109504677/68d190b7-e255-470e-b067-e1c9e77b71b7\" alt=\"metamask-reply\"></p>\n<p>我非常同意他的看法。但我仍然想知道为什么之前会将此类代码放入代码库中。</p>\n<h2>结束</h2>\n<p>文章到此结束。我希望它能解释 MetaMask 钱包如何存储你的钱包秘密的基础知识。如果您想了解更多详细信息，可以在他们的 GitHub 存储库 <a href=\"https://github.com/MetaMask\">https://github.com/MetaMask</a> 中阅读其源代码。</p>\n<p>==========================🦊附录🦊======================= ===</p>\n<p>用于创建新钱包的非常粗略的代码路径：</p>\n<blockquote>\n<ol>\n<li><a href=\"https://github.com/MetaMask/metamask-extension/blob/889ca62723b53516d28c9307f766ca4e065cc126/ui/app/pages/first-time-flow/first-time-flow.component.js#L70\">metamask-extension/ui/app/pages/first-time-flow/first-time-flow.component.js</a></li>\n</ol>\n<pre class=\"prettyprint language-js\"><code>const seedPhrase = await createNewAccount(password)\n</code></pre><ol>\n<li><a href=\"https://github.com/MetaMask/metamask-extension/blob/889ca62723b53516d28c9307f766ca4e065cc126/ui/app/pages/first-time-flow/first-time-flow.container.js#L37\">metamask-extension/ui/app/pages/first-time-flow/first-time-flow.container.js</a></li>\n</ol>\n<pre class=\"prettyprint language-js\"><code>createNewAccount: (password) =&gt; dispatch(createNewVaultAndGetSeedPhrase(password))\n</code></pre><ol>\n<li><a href=\"https://github.com/MetaMask/metamask-extension/blob/889ca62723b53516d28c9307f766ca4e065cc126/ui/app/store/actions.js#L117\">metamask-extension/ui/app/store/actions.js</a></li>\n</ol>\n<pre class=\"prettyprint language-js\"><code>export function createNewVaultAndGetSeedPhrase(password){\n   ....\n   await createNewVault(password)\n   const seedWords = await verifySeedPhrase()\n   ....\n}\n</code></pre><ol>\n<li><a href=\"https://github.com/MetaMask/metamask-extension/blob/889ca62723b53516d28c9307f766ca4e065cc126/app/scripts/metamask-controller.js#L865\">metamask-extension/app/scripts/metamask-controller.js</a></li>\n</ol>\n<pre class=\"prettyprint language-js\"><code>async createNewVaultAndKeychain(password){\n   vault = await this.keyringController.createNewVaultAndKeychain(password)\n}\n</code></pre><ol>\n<li><a href=\"https://github.com/MetaMask/KeyringController/blob/1a0dbbaf45e54e7b80200d4a9c6b21ce74b61b2f/index.js#L70\">KeyringController/blob/master/index.js</a></li>\n</ol>\n<pre class=\"prettyprint language-js\"><code>createNewVaultAndKeychain (password) {\n   return this.persistAllKeyrings(password)\n       .then(this.createFirstKeyTree.bind(this))\n       .then(this.persistAllKeyrings.bind(this, password))\n       .then(this.setUnlocked.bind(this))\n       .then(this.fullUpdate.bind(this))\n}\n</code></pre><ol>\n<li><a href=\"https://github.com/MetaMask/KeyringController/blob/1a0dbbaf45e54e7b80200d4a9c6b21ce74b61b2f/index.js#L492\">MetaMask/KeyringController/blob/master/index.js</a></li>\n</ol>\n<pre class=\"prettyprint language-js\"><code>createFirstKeyTree () {\n   ...\n   return this.addNewKeyring(&#x27;HD Key Tree&#x27;, { numberOfAccounts: 1 })\n   ...\n}\n</code></pre><ol>\n<li><a href=\"https://github.com/MetaMask/KeyringController/blob/1a0dbbaf45e54e7b80200d4a9c6b21ce74b61b2f/index.js#L103\">MetaMask/KeyringController/blob/master/index.js</a></li>\n</ol>\n<pre class=\"prettyprint language-js\"><code>addNewKeyring (type, opts) {\n   ...\n   const Keyring = this.getKeyringClassForType(type)\n   const keyring = new Keyring(opts)\n   ...\n}\n</code></pre></blockquote>\n<ol>\n<li><a href=\"https://github.com/MetaMask/eth-hd-keyring/blob/44d2b1effc0eec0eaf811763eb74ec3118b6903e/index.js#L45\">MetaMask/eth-hd-keyring/blob/master/index.js</a></li>\n</ol>\n<pre class=\"prettyprint language-js\"><code>addAccounts (numberOfAccounts = 1) {\n    ...\n    this._initFromMnemonic(bip39.generateMnemonic())\n    ...\n}\n</code></pre><hr>\n<h3>往期回顾</h3>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=Mzk0NDM5NzkwNg==&amp;mid=2247483849&amp;idx=1&amp;sn=18920019b11ce4c61718874266faa9b0&amp;chksm=c3240af4f45383e2ea46f21d3d65d7d47186e74d435878859a9682503d3fffe5bb709bd8976b&amp;token=710208366&amp;lang=zh_CN#rd\">辞职 All in Web3 一年的回顾以及一些对 Web3 NFT 的看法见解 （一）</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=Mzk0NDM5NzkwNg==&amp;mid=2247483881&amp;idx=1&amp;sn=93c85b1d9e8459c4d36f0184b19a5b90&amp;chksm=c3240ad4f45383c287de88ad8247e124572e4c554172e8367eb0140958550052b32348168033&amp;token=710208366&amp;lang=zh_CN#rd\">辞职 All in Web3 一年的回顾以及一些对 Web3 NFT 的看法见解 （二）</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=Mzk0NDM5NzkwNg==&amp;mid=2247483903&amp;idx=1&amp;sn=8f66059eac6de805c7e8340dc322b0a0&amp;chksm=c3240ac2f45383d43d5dea6abe59cfaf302c35a53c51d90d51d2203b2481c1ca2422ce22031e&amp;payreadticket=HK0vH-VgFuwBPr4gN2wYXhvqXGV5ld6kPkiC4AJp1ZdDicfP6ZQzJOMyOJz1AR0qFcEOMzY#rd\">对于 2023 至 2025 年是 Web3 的 iPhone 时刻 文章的一些看法</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=Mzk0NDM5NzkwNg==&amp;mid=2247483903&amp;idx=2&amp;sn=35e4a0c768248644719be77e64432075&amp;chksm=c3240ac2f45383d4ff5bb1caad8636d30836647ca492560b1c2598776bc601dfa7f7b8c6cacb&amp;payreadticket=HDoD_mLn3oAbe1ycn9lkwy8l9ckXsxRtY7u_hTWI6SsrfGXWiMCYYqWdSlGb8p8pwMuQdjg#rd\">申请 Alliance 投资孵化的一些小贴士</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=Mzk0NDM5NzkwNg==&amp;mid=2247483778&amp;idx=1&amp;sn=a43130fe5e9c5132986f892a724040b2&amp;chksm=c3240abff45383a9a14b200503680abfe00ff67eedb62ed8d98aaa99f97264651ba1259a56b5&amp;token=1902673380&amp;lang=zh_CN#rd\">介绍下Web3赏金黑客们必备的开箱即用 Web3 元宇宙 NFT 开发必备脚手架</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=Mzk0NDM5NzkwNg==&amp;mid=2247483715&amp;idx=1&amp;sn=4c39648183b0cb2781819e3a065d0a86&amp;chksm=c3240a7ef45383681fff64cff623ef0a9590abf8f6f31e015975210ebc64d1f1b67f26356fa7&amp;token=1411723489&amp;lang=zh_CN#rd\">一个解决方案来让你的 NFT 拥有无限可能</a></li>\n</ul>\n</div>",
    "title": "最新的一些 Web3 开发相关技术栈更新 && MetaMask 是怎么保存你的钱包秘钥的？",
    "last_reply_at": "2023-05-29T10:39:32.386Z",
    "good": false,
    "top": false,
    "reply_count": 1,
    "visit_count": 79,
    "create_at": "2023-05-29T09:45:39.971Z",
    "author": {
      "loginname": "lyman",
      "avatar_url": "//gravatar.com/avatar/f2764a9cb957064880b772775ee93918?size=48"
    }
  },
  {
    "id": "6472040256d98338679d9680",
    "author_id": "5d47c83b4f472f7fee152927",
    "tab": "ask",
    "content": "<div class=\"markdown-text\"><p>哈哈，我真是太容易遇到这种困扰了，但是真的不想因为判断个整数，引入一个大库。</p>\n<p>需求是这样的，从 url 里取出一个参数 <code>num</code>，我要判断 <code>num</code> 是否为正整数：</p>\n<pre class=\"prettyprint language- js\"><code>function is_int(value_raw) {\n  const value = parseInt(value_raw)\n  return value == value_raw ? value : false\n}\n</code></pre><p>如果返回 false，那么 <code>value_raw</code> 就不是整数<br>\n否则是整数，且返回值就是对应的整数类型的值</p>\n<p>看起来比较简洁，但是我担心使用 <code>parseInt(value_str) == value</code> 不够严谨<br>\n因此请教一下友友们，不知道有没有什么反例</p>\n<p>我已经测试了这些情况：</p>\n<pre class=\"prettyprint language- js\"><code>parseInt(&#x27;1&#x27;) == &#x27;1&#x27; &#x2F;&#x2F; true\nparseInt(&#x27;-1&#x27;) == &#x27;-1&#x27; &#x2F;&#x2F; true\nparseInt(NaN) == NaN &#x2F;&#x2F; false。没错，NaN == NaN 是 false\nparseInt(1.1) == 1.1 &#x2F;&#x2F; false\nparseInt(&#x27;1.1&#x27;) == &#x27;1.1&#x27; &#x2F;&#x2F; false\nparseInt(true) == true &#x2F;&#x2F; false\nparseInt(false) == false &#x2F;&#x2F; false\nparseInt(&#x27;true&#x27;) == &#x27;true&#x27; &#x2F;&#x2F; false\nparseInt(&#x27;false&#x27;) == &#x27;false&#x27; &#x2F;&#x2F; false\n</code></pre><p>但是 <code>'1.0'</code> 竟然也是 true，不过需求是判断 <strong>可解析为整数</strong>，所以也不算反例：</p>\n<pre class=\"prettyprint language- js\"><code>&#x27;1.0&#x27; == parseInt(&#x27;1.0&#x27;) &#x2F;&#x2F; true \n</code></pre></div>",
    "title": "可不可以使用 num == parseInt(num) 来判断 num 可解析为整数？",
    "last_reply_at": "2023-05-29T01:19:53.403Z",
    "good": false,
    "top": false,
    "reply_count": 1,
    "visit_count": 173,
    "create_at": "2023-05-27T13:22:10.995Z",
    "author": {
      "loginname": "daGaiGuanYu",
      "avatar_url": "https://avatars.githubusercontent.com/u/27003009?v=4&s=120"
    }
  },
  {
    "id": "6470196b56d983c8499d961b",
    "author_id": "531d79d02b347efe3900cf0e",
    "tab": "share",
    "content": "<div class=\"markdown-text\"><p>实现了在公众号里接入chatgpt，与其他公众号的接入有以下几点不同：</p>\n<p>1.<strong>内置了一些角色</strong>，这些角色已经设置好了提示词，用户可直接使用。比如私人翻译、英语家教、说文解字等。</p>\n<p>2.<strong>可以自定义角色</strong>，根据需要自己写提示词</p>\n<p>3.<strong>可以语音输入和语音输出</strong>，可以用语音的方式输入和返回结果，</p>\n<p>4.<strong>长文本和长语音可以分段输出</strong>，当返回的文本或语音太长时，可以将它们分成多段再发送。</p>\n<p>5.<strong>绑定api key</strong>，如果用户自己有api key，可以绑定api key后再使用。</p>\n<p><img src=\"//static.cnodejs.org/Ftyv48555VV7IhJTc2PNtELkccPM\" alt=\"vv2\"></p>\n<p><strong>编程语言</strong>\n用到的技术主要是：nodejs和mysql</p>\n<p>扫描下面二维码关注公众号，关注后就可以体验了\n<img src=\"//static.cnodejs.org/FnO9TgqyPSskBmMr3_-h0PZ7Wimn\" alt=\"qrcode_for_gh_10a982e801c1_430.jpg\"></p>\n</div>",
    "title": "实现了公众号接入ChatGPT",
    "last_reply_at": "2023-05-26T02:28:59.983Z",
    "good": false,
    "top": false,
    "reply_count": 0,
    "visit_count": 227,
    "create_at": "2023-05-26T02:28:59.983Z",
    "author": {
      "loginname": "mityburner",
      "avatar_url": "https://avatars.githubusercontent.com/u/5137150?v=4&s=120"
    }
  },
  {
    "id": "646c30e02671930a5d5b7fe0",
    "author_id": "53210c6161ed405564019381",
    "tab": "share",
    "content": "<div class=\"markdown-text\"><p>开源项目地址：<a href=\"https://github.com/eleme/morjs\">https://github.com/eleme/morjs</a>，欢迎试用 ~</p>\n<p>喜欢么？或者对您有用？ <a href=\"https://github.com/eleme/morjs\">☞ 立即去 ⭐️ Star ⭐️ 一下 ☞</a></p>\n<h1>MorJS 是什么？</h1>\n<h3>简介</h3>\n<p>Mor (发音为 /mɔːr/，类似 more) 是饿了么开发的<strong>一款</strong> <strong>基于小程序 DSL 的，可扩展的多端研发框架。</strong></p>\n<p>使用 MorJS，我们只需书写一套（微信或支付宝）小程序，就可以通过 MorJS 的<strong>转端编译能力</strong>，将源码分别编译出可以发布在不同端（微信/支付宝/百度/字节/钉钉/快手/QQ/淘宝/H5）的产物。MorJS 还支持小程序、小程序插件、小程序分包之间的<strong>形态转换</strong>，同时也配备了从源码到构建产物全阶段的<strong>插件体系</strong>，满足各类功能扩展，提升开发体验和开发效率。</p>\n<h3>示例</h3>\n<p>以下是饿了么-美食外卖频道在微信、支付宝、抖音小程序及 H5 中的表现：</p>\n<p><img src=\"//static.cnodejs.org/Ft8BJ5QsaNK1u_nBEvmACF6DGKqW\" alt=\"20f90566c7a34ec8a1694c83efd4b303~tplv-k3u1fbpfcp-watermark.jpeg\"></p>\n<h1>为什么要做 MorJS？</h1>\n<p>目前各大平台都相继推出了自己的小程序，饿了么 C 端业务需要在不同平台小程序进行投放，这些项目大多是以支付宝或微信原生 DSL 编写，面对业务渠道的不断增加，我们尝试了多种方法来兼容多端适配，但由于不同平台间小程序代码写法、能力支持的差异性逐步变大，过去的方案无法满足新业务的需求，我们需要一套跨端研发框架能解决以下诉求：</p>\n<ul>\n<li><strong>原生 DSL 支持</strong>，方便现有小程序 DSL 编写的存量业务使用；</li>\n<li><strong>降低性能开销</strong>，尽可能轻运行时，减少编译构建的时长；</li>\n<li><strong>便捷的使用</strong>，一键转换为支持各小程序平台使用的产物；</li>\n<li><strong>拓展的功能</strong>，提供针对大型复杂小程序的解耦方案；</li>\n<li><strong>灵活的配置</strong>，能够简单的增加修改多套不同端的项目配置；</li>\n<li><strong>产物优化能力</strong>，压缩构建产物体积，减少小程序包大小；</li>\n</ul>\n<p>在明确这几点后，我们调研了业界所有主流技术框架，发现并没有能完全满足我们需求的方案，所以我们决定自研 MorJS。</p>\n<h1>如何使用？</h1>\n<p>MorJS 是基于小程序原生 DSL 进行扩展的，只要你掌握微信或支付宝任意一种小程序，那你就几乎掌握了 MorJS。</p>\n<p>MorJS 提供了官方脚手架工具用于创建新项目，同时也支持已有小程序引入相关依赖接入 MorJS。</p>\n<h3>开始一个新项目</h3>\n<p>MorJS 项目示例：<a href=\"https://github.com/eleme/morjs/tree/main/examples\">https://github.com/eleme/morjs/tree/main/examples</a></p>\n<ol>\n<li>创建项目，选定项目目录，在目录终端执行以下任一命令：</li>\n</ol>\n<pre class=\"prettyprint language-shell\"><code>$ npm init mor # npm 创建项目\n$ yarn create mor # yarn 创建项目\n$ pnpm create mor # pnpm 创建项目\n</code></pre><ol>\n<li>选择对应的工程类型，按照提示完成初始化操作</li>\n</ol>\n<pre class=\"prettyprint language-shell\"><code>✔ 请选择工程类型 › 小程序\n✔ 请选择源码类型 › 微信小程序 DSL\n✔ 是否使用 Typescript … 否 &#x2F; 是\n✔ 请选择 CSS 预处理器 › less\n✔ 请输入 小程序 的名称 … myapp\n✔ 请输入 小程序 的描述 … my first app\n✔ 用户名 … yourUserName\n✔ 邮箱 … your@gmail.com\n✔ 请输入 Git 仓库地址 … https:&#x2F;&#x2F;github.com&#x2F;yourUserName&#x2F;myapp\n✔ 请选择 npm 客户端 › npm &#x2F; pnpm &#x2F; yarn\n…\n</code></pre><ol>\n<li>执行编译命令启动项目：</li>\n</ol>\n<pre class=\"prettyprint language-shell\"><code>$ npm run dev\n</code></pre><ol>\n<li>多端产物已构建在 <em>dist</em> 目录下，分别用对应平台的 IDE 打开即可开发预览</li>\n</ol>\n<h3>已有小程序项目接入</h3>\n<ol>\n<li>在已有项目中添加必要的依赖：</li>\n</ol>\n<pre class=\"prettyprint language-shell\"><code>$ npm i @morjs&#x2F;cli -D &amp;&amp; npm i @morjs&#x2F;core --save\n</code></pre><ol>\n<li>在项目根目录下增加配置文件 <em>mor.config.ts</em></li>\n</ol>\n<pre class=\"prettyprint language-typescript\"><code>import { defineConfig } from &#x27;@morjs&#x2F;cli&#x27;\n\nexport default defineConfig([\n  &#x2F;&#x2F; 第一套配置: 微信 DSL 编译\n  {\n    name: &#x27;wx&#x27;,\n    sourceType: &#x27;wechat&#x27;, &#x2F;&#x2F; 源码类型: 微信 DSL\n    target: &#x27;wechat&#x27;, &#x2F;&#x2F; 编译目标: 微信\n    compileMode: &#x27;bundle&#x27;, &#x2F;&#x2F; 编译模式: 打包模式\n  },\n  &#x2F;&#x2F; 第二套配置: 微信转支付宝\n  {\n    name: &#x27;ali&#x27;,\n    sourceType: &#x27;wechat&#x27;, &#x2F;&#x2F; 源码类型: 微信 DSL\n    target: &#x27;alipay&#x27;, &#x2F;&#x2F; 编译目标: 支付宝\n    compileMode: &#x27;bundle&#x27;, &#x2F;&#x2F; 编译模式: 打包模式\n  },\n  &#x2F;&#x2F; 第三套配置: 微信转 Web\n  {\n    name: &#x27;web&#x27;,\n    sourceType: &#x27;wechat&#x27;, &#x2F;&#x2F; 源码类型: 微信 DSL\n    target: &#x27;web&#x27;, &#x2F;&#x2F; 编译目标: Web\n    compileMode: &#x27;bundle&#x27;, &#x2F;&#x2F; 编译模式: 打包模式\n  }\n])\n</code></pre><ol>\n<li>在 <em>package.json</em> 中配置脚本：</li>\n</ol>\n<pre class=\"prettyprint language-json\"><code>{\n  &quot;scripts&quot;: {\n+   &quot;dev&quot;: &quot;mor compile -w&quot;,\n+   &quot;build&quot;: &quot;mor compile --production&quot;\n  }\n}\n</code></pre><ol>\n<li>在项目目录终端下执行编译命令启动项目：</li>\n</ol>\n<pre class=\"prettyprint language-shell\"><code>$ npm run dev\n</code></pre><ol>\n<li>多端产物已构建在 <em>dist</em> 目录下，分别用对应平台的 IDE 打开即可开发预览。</li>\n</ol>\n<h1>MorJS 核心能力</h1>\n<h3>多端编译：提供一码多端转换能力</h3>\n<p>从诞生之初，MorJS 的一个核心能力就是实现小程序一码多端的转换，让一套代码经过编译后对应的各端产物，分别在多个小程序平台上运行，让开发成本，招聘、管理、测试各方面成本都大幅下降。截止到目前，我们已经支持多数小程序平台的转换。</p>\n<p>如果你对多端编译的实现感兴趣，可参见文档<a href=\"https://mor.eleme.io/guides/introduction/how-mor-works\">《MorJS 如何工作》</a></p>\n<p><img src=\"//static.cnodejs.org/Fjw7qsWJRy464xjpEdicZuDotyL9\" alt=\"d1fcd68695014df4957c92467394b2bc~tplv-k3u1fbpfcp-watermark.jpeg\"></p>\n<h3>集成研发：提供复杂小程序解耦开发能力</h3>\n<p>随着业务需求的不断增加，很多小程序项目不可避免的会出现体积巨大化的问题。虽然小程序官方提供了小程序分包、小程序插件的解决方案，但基于同一个小程序代码库，众多分包、插件的迭代情况复杂，实际业务难以解耦。如果你的项目遇到类似的问题，可以使用 MorJS 提供的集成研发能力，把各个分包、插件、模块分成一个个独立的项目，并通过集成研发将小程序宿主和这些子模块通过拉包、编译、构建、合并等一系列处理，合并为一个完整小程序进行开发、调试和部署。</p>\n<p>如果你对集成研发的实现感兴趣，可参见文档<a href=\"https://mor.eleme.io/guides/advance/complex-miniprogram-integration\">《复杂小程序集成》</a></p>\n<p><img src=\"//static.cnodejs.org/FkB04_oTjKB_myh44K4iPFBfCgtG\" alt=\"bd1b7d97b5d145b09a81e8a8c787feaf~tplv-k3u1fbpfcp-watermark.jpg\"></p>\n<h3>形态互转：提供小程序多形态转换能力</h3>\n<p>（<strong>如果你的项目没有类似诉求可以跳过本段内容</strong>）随着投放场景的增加，不同业务在不同小程序端的形态可能并不相同。例如一个在支付宝端的小程序应用，在某些场景下希望他以分包的形式接入到微信小程序中。于是让项目在独立小程序、小程序插件、小程序分包应用形态间互相转换成为一个难题。</p>\n<p>MorJS 提供的形态一体化能力，可以在尽量减少业务代码修改的前提下，提供<strong>同一个项目在以不同端（微信、支付宝、淘宝、抖音等）不同形态（小程序、小程序插件、小程序分包）间的转换能力。</strong></p>\n<p>如果你对形态一体化的实现感兴趣，可参见文档<a href=\"https://mor.eleme.io/guides/advance/unity-of-forms\">《小程序形态互换》</a></p>\n<p><img src=\"//static.cnodejs.org/FpOkt6QmYMm14me4Fp3oMlSgSfOG\" alt=\"4ebd7e68d19d4e7096c0c6a1dbe0a929~tplv-k3u1fbpfcp-watermark.jpg\"></p>\n<h3>H5 同构：提供小程序 DSL 转 H5 能力</h3>\n<p>除了多端多形态的小程序外，不少开发者还面临着 H5 场景的投放。对此， MorJS 提供将小程序项目转换为 Web 项目的能力。这一能力的核心是将小程序转换成一个基于 <strong>React</strong> 的项目产物。无论是整个工程项目的转码、或是单个组件的编译，MorJS 都能够支持。</p>\n<p>如果你对转 Web 开发的实现感兴趣，可参见文档<a href=\"https://mor.eleme.io/web/basic/quickstart\">《MorJS Web 开发》</a></p>\n<p><img src=\"//static.cnodejs.org/FlLqIKMy8AEkqG_S-tmrO4qnO7Mn\" alt=\"0e2968712b9e428b960e625a9040261e~tplv-k3u1fbpfcp-watermark.jpg\"></p>\n<h3>其他</h3>\n<p>除此上述核心能力外，MorJS 围绕小程序实现了一系列研发生态能力的建设，包括但不限于以下：</p>\n<ul>\n<li>条件编译：提供对于多端或不同环境构建产出不同代码的能力，更加灵活的解决不同场景的适配问题；</li>\n<li>产物压缩：提供了不同类型文件的最小化兼容压缩方式，并保留配置选项对高级压缩方案的扩展支持；</li>\n<li>Mock 能力：提供小程序本地 JSAPI mock 能力，解决开发阶段无法联调接口请求数据的痛点；</li>\n<li>…</li>\n</ul>\n<h1>优势与现状</h1>\n<h3>MorJS 的优势</h3>\n<p>如你所见，MorJS 是一套基于小程序 DSL (支付宝或微信) 的框架。他的易用性、标准化和灵活性，使得开发者能更好地专注于业务，降低研发、调试成本，提高开发者的工作效率。</p>\n<p><img src=\"//static.cnodejs.org/FtyKgnWy3CVs1stS8hZOA6uh4VAo\" alt=\"4d15f812a67e412fba159948051b53a0~tplv-k3u1fbpfcp-watermark.jpg\"></p>\n<h3>使用现状</h3>\n<p>截止目前，MorJS 支持 4 种编译形态（小程序、小程序插件、小程序分包、H5），支撑了饿了么 C 端大多数业务在各个渠道上的研发和投放。通过 MorJS 的开源，我们期望能把其中的技术细节、架构设计和技术思考呈现给大家，为有类似多端同构需求的企业和开发者服务。</p>\n<h1>结语</h1>\n<p>MorJS 为饿了么解决了大量业务在多端研发上的差异问题，让小程序开发的重心回到产品业务本身，减少使用者对多端差异兼容的投入，在通过开源让大家更好地了解和使用这项技术的同时，我们也希望能够借此吸引到更多志趣相投的小伙伴参与共建，一起加速小程序一码多端能力的发展。欢迎广大小程序开发者们与我们交流。</p>\n<p>以上是对 MorJS 的简单介绍，如果想要详细了解可通过下述方式：</p>\n<ul>\n<li>GitHub：<a href=\"https://github.com/eleme/morjs\">https://github.com/eleme/morjs</a></li>\n<li>官网地址：<a href=\"https://mor.eleme.io/\">https://mor.eleme.io/</a></li>\n<li>加入 MorJS 社区服务群：钉钉扫码或搜索群号「29445021084」咨询或了解更多 👇</li>\n</ul>\n<p><img src=\"//static.cnodejs.org/FmDw_anol-1QEFSDSxSF8Dev0MdR\" alt=\"O1CN01heyxL41IHacBtHYT1_!!6000000000868-2-tps-828-1068.png\"></p>\n</div>",
    "title": "饿了么开源自研多端框架 MorJS",
    "last_reply_at": "2023-05-23T03:20:00.704Z",
    "good": false,
    "top": false,
    "reply_count": 0,
    "visit_count": 1175,
    "create_at": "2023-05-23T03:20:00.704Z",
    "author": {
      "loginname": "lyfeyaj",
      "avatar_url": "https://avatars.githubusercontent.com/u/1445568?v=4&s=120"
    }
  },
  {
    "id": "640ec16a00720877209e443c",
    "author_id": "5c81f15090c14711cc8cb87e",
    "tab": "share",
    "content": "<div class=\"markdown-text\"><p>NestJs周下载量已经达到200多万了 用nestjs开发的人多还是midway多？</p>\n<p><img src=\"//static.cnodejs.org/Ftx8B1sj-zY5bLEFJA5ObHwGec8G\" alt=\"nestjs8.png\"></p>\n</div>",
    "title": "NestJs周下载量已经达到200多万了 用nestjs开发的人多还是midway多--各位老铁用的什么",
    "last_reply_at": "2023-05-22T03:15:00.822Z",
    "good": false,
    "top": false,
    "reply_count": 8,
    "visit_count": 3344,
    "create_at": "2023-03-13T06:23:38.506Z",
    "author": {
      "loginname": "phonegap100",
      "avatar_url": "https://avatars.githubusercontent.com/u/5773766?v=4&s=120"
    }
  },
  {
    "id": "64620eeb627faa6269659b5a",
    "author_id": "56430dff0fb76caf5bf095fb",
    "tab": "share",
    "content": "<div class=\"markdown-text\"><p>项目地址：<a href=\"https://github.com/sinajia/express-jwt-session2\">https://github.com/sinajia/express-jwt-session2</a>\n目标：\n把session保存在client端的cookie里面，跟使用redis、MongoDB等保存session info，client端保存key的方案类似。\n信息用aes加密，client端base64解码之后也看不到原文。\n支持签名。\n做成express中间件，用户代码使用req.session得到session。</p>\n<p>使用aes加密\n使用jwt机制sign和verify</p>\n</div>",
    "title": "基于jwt签名的分布式express session中间件",
    "last_reply_at": "2023-05-15T10:52:27.937Z",
    "good": false,
    "top": false,
    "reply_count": 0,
    "visit_count": 712,
    "create_at": "2023-05-15T10:52:27.937Z",
    "author": {
      "loginname": "classfellow",
      "avatar_url": "https://avatars.githubusercontent.com/u/7146748?v=4&s=120"
    }
  },
  {
    "id": "645da8a5627faa295e659ac4",
    "author_id": "5b4fdf5faef62f1b0f9e0434",
    "tab": "share",
    "content": "<div class=\"markdown-text\"><p>基于node.js sse-server重构后，现已支持消息stream流式回复。\n<strong><a href=\"https://v.douyin.com/UdKFoHr/\">演示视频点这里</a></strong>\n微信扫描下方二维码即可下载安装体验\n<img src=\"//static.cnodejs.org/FmX66Rv0t6wbKFRlxVlqBsVqI1TI\" alt=\"二维码 (2).png\"></p>\n</div>",
    "title": "文丑-ChatGPT客户端 支持消息打字机式回复啦，响应时间毫秒级",
    "last_reply_at": "2023-05-12T02:47:01.702Z",
    "good": false,
    "top": false,
    "reply_count": 0,
    "visit_count": 873,
    "create_at": "2023-05-12T02:47:01.702Z",
    "author": {
      "loginname": "assmdx",
      "avatar_url": "https://avatars.githubusercontent.com/u/19722693?v=4&s=120"
    }
  },
  {
    "id": "645b9925627faadd3b659a58",
    "author_id": "5b4fdf5faef62f1b0f9e0434",
    "tab": "share",
    "content": "<div class=\"markdown-text\"><p>今天打开App突然发现请求全部报错，看了眼服务器发现CPU负载100%，监控内存曲线一直上涨，推测是内存泄露问题，\n在代码中加入以下代码：</p>\n<pre class=\"prettyprint\"><code>import v8 from &#x27;node:v8&#x27;\n\nprocess.on(&#x27;warning&#x27;, e =&gt; console.warn(e.stack))\n\nprocess.on(&#x27;SIGUSR2&#x27;, () =&gt; {\n  const fileName = v8.writeHeapSnapshot();\n  console.log(&#96;Created heapdump file: ${fileName}&#96;);\n})\n</code></pre><p>在服务器上新启一个服务，端口换成8999，\n启动新服务后，执行</p>\n<pre class=\"prettyprint\"><code>kill -SIGUSR2 11044 &#x2F;&#x2F; 新服务的pid\n</code></pre><p>打一个测试包，服务器端口换成新服务的8999，不停发请求，\n然后执行</p>\n<pre class=\"prettyprint\"><code>kill -SIGUSR2 11044 &#x2F;&#x2F; 新服务的pid\n</code></pre><p>抓取到新的内存快照。</p>\n<p>将两个内存快照下载到本地，用chrome dev tools/ Memory Load进去，对比发现依赖的某个包吃了很多内存\n<img src=\"//static.cnodejs.org/FqI2bOxGcS02ESZEqSaqL07lxSuS\" alt=\"image.png\">\n在网上搜，果然发现这个依赖包是有问题的\n<a href=\"https://pullanswer.com/questions/always-meet-error-from-atdqbd-tiktoken-and-cause-memory-leak\">https://pullanswer.com/questions/always-meet-error-from-atdqbd-tiktoken-and-cause-memory-leak</a>\n按教程修改后，memory leak消失：\n<img src=\"//static.cnodejs.org/FnGg8qU9WOfW4hq_r2z6JWi10GBs\" alt=\"image.png\"></p>\n<p>最后，欢迎大家下载体验我开发的App ChatGPT客户端/文丑App:\n<img src=\"https://imgs.wiki/imgs/2023/05/10/c600e28d54e3ca24.png\" alt=\"image.png\"></p>\n</div>",
    "title": "记一次排查内存泄露问题",
    "last_reply_at": "2023-05-10T13:25:11.779Z",
    "good": false,
    "top": false,
    "reply_count": 2,
    "visit_count": 812,
    "create_at": "2023-05-10T13:16:21.367Z",
    "author": {
      "loginname": "assmdx",
      "avatar_url": "https://avatars.githubusercontent.com/u/19722693?v=4&s=120"
    }
  },
  {
    "id": "6224234d65073a06fe32f191",
    "author_id": "5b5ab83e2860af042a217916",
    "tab": "ask",
    "content": "<div class=\"markdown-text\"><p>目前我在用nestjs</p>\n</div>",
    "title": "大家开发都用什么框架呢？",
    "last_reply_at": "2023-05-09T05:56:11.357Z",
    "good": false,
    "top": false,
    "reply_count": 13,
    "visit_count": 10212,
    "create_at": "2022-03-06T02:58:21.228Z",
    "author": {
      "loginname": "h-cenggel",
      "avatar_url": "https://avatars.githubusercontent.com/u/24600623?v=4&s=120"
    }
  },
  {
    "id": "644b52a66779ea950314e5cc",
    "author_id": "56430dff0fb76caf5bf095fb",
    "tab": "share",
    "content": "<div class=\"markdown-text\"><p>刚上传了一个自己实现的项目，我已经运行起来了：<a href=\"https://github.com/sinajia/wechatbot-nodejs\">https://github.com/sinajia/wechatbot-nodejs</a>\n支持用户在本地电脑扫码登录，接入GPT，让自己的微信自动回复消息。\n本项目可以实现：\n群聊@回复\n私聊回复\n特定提问回复\n<img src=\"//static.cnodejs.org/FiJX8l7PeP55gxkY0f7V4TXnpUTT\" alt=\"group.jpg\">\ntodo\n后期支持发送图片和gif动画，活跃群气氛。</p>\n</div>",
    "title": "微信接入GPT",
    "last_reply_at": "2023-05-08T15:57:47.097Z",
    "good": false,
    "top": false,
    "reply_count": 4,
    "visit_count": 1495,
    "create_at": "2023-04-28T04:59:18.598Z",
    "author": {
      "loginname": "classfellow",
      "avatar_url": "https://avatars.githubusercontent.com/u/7146748?v=4&s=120"
    }
  },
  {
    "id": "645850646779eab79b14e8ad",
    "author_id": "53aecc6fa087f4562011cc62",
    "tab": "share",
    "content": "<div class=\"markdown-text\"><p>hhhhh有点广告</p>\n</div>",
    "title": "求扩列，rust react 加我snowmanzzz（wechat）",
    "last_reply_at": "2023-05-08T01:29:08.146Z",
    "good": false,
    "top": false,
    "reply_count": 0,
    "visit_count": 868,
    "create_at": "2023-05-08T01:29:08.146Z",
    "author": {
      "loginname": "zzz6519003",
      "avatar_url": "https://avatars.githubusercontent.com/u/1625608?v=4&s=120"
    }
  },
  {
    "id": "63845c78f0ccaefffee0f0b0",
    "author_id": "59eeb8e11bbf067d5c3fa7c6",
    "tab": "share",
    "content": "<div class=\"markdown-text\"><p>上学时喜欢帮同桌找错，一个英文句子如果能找到5处错误，心里就美滋滋的。如今轮到自己写技术文档，面对满篇的中式英语却有心无力。好心的网友，如果开发累了，就摸个鱼🐟，帮我找找错吧，也找回学生时代的感觉</p>\n<ul>\n<li>原文链接：<a href=\"https://cabloy.com/articles/how-to-read.html\">How to Study CabloyJS</a></li>\n</ul>\n<p>============ 正文分隔线 ============</p>\n<hr>\n<h1><strong>How to Study CabloyJS?</strong></h1>\n<h2><strong>Document Audiences</strong></h2>\n<p>Software development is like building houses and bridges, which can be the towering palaces in the north, the elegant courtyards in the south, and even the precipitous and isolated bridges beyond mountains. Then, different languages and frameworks attract a group of fans by their inherent qualities. They work tirelessly to create different ecosystems and present different development styles and experiences. Just as <code>Rails to Ruby</code>, <code>Lavaral to PHP</code>, <code>Django to Python</code>, and <code>Spring Boot to Java</code>. So, what will be to Javascript? There is no doubt that Javascript faces more usage scenarios, such as front-end, back-end, mobile, IOT, etc. Different scenarios have excellent solutions. Moreover, based on different usage habits, the javascript ecosystem is split into two style systems, which are <code>Javascript</code> and <code>Typescript</code>. So, based on business development, in terms of the current node ecology, we can say that <code>Nest to Typescript</code>, and <code>Cabloy to Javascript</code></p>\n<p>Because different languages and frameworks will have different solutions and styles. Therefore, whether you use <code>CabloyJS</code> or not, it is necessary to come in and see what kind of flowers can grow on the soil of sticking to the pure javascript (Vanilla JS). Therefore, whether you are a fan of front-end development, back-end development, full stack development, or other languages, or a technical manager, product manager, or project manager, you can learn different ideas and methods for solving problems from the documents and videos provided by CabloyJS, communicate with each other, learn from each other, and make progress together!</p>\n<table>\n<thead>\n<tr>\n<th><strong>Language</strong></th>\n<th><strong>Framework</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Ruby</td>\n<td>Rails</td>\n</tr>\n<tr>\n<td>PHP</td>\n<td>Lavaral</td>\n</tr>\n<tr>\n<td>Python</td>\n<td>Django</td>\n</tr>\n<tr>\n<td>Java</td>\n<td>Spring Boot</td>\n</tr>\n<tr>\n<td>Typescript</td>\n<td>Nest</td>\n</tr>\n<tr>\n<td>Javascript</td>\n<td>Cabloy</td>\n</tr>\n</tbody>\n</table>\n<h2><strong>What is CabloyJS</strong></h2>\n<p>CabloyJS is a NodeJS full-stack framework with workflow engine, a low-code development platform for developers, is also a PAAS platform with both out-of-the-box and flexible-customization. Only one set of codes is needed to realize the admin management system at backend and the applications at frontend at the same time. Only one set of codes is needed to adapt to PC and mobile at the same time, and the mobile is close to the native experience</p>\n<h2>Framework styles and design principles of CabloyJS</h2>\n<h3>1. Framework styles: <code>brief-but-not-simple</code></h3>\n<h3>2. Design principles: <code>out-of-the-box</code> + <code>flexible-customization</code></h3>\n<p>Many friends feedback that they are unfamiliar with the concepts of CabloyJS, so they don’t know where to start?</p>\n<p>Different languages and architecture concepts determine the style of a framework. In order to create a truly easy-to-use full stack business framework, CabloyJS abstracts and refines the concepts behind the real business requirements, which not only achieves the effect of out-of-the-box, but also can be customized flexibly</p>\n<p>Therefore, this also determines that the overall style of CabloyJS framework is: <code>brief-but-not-simple</code>. When you are familiar with this style, you will find that the really comfortable development experience should be like this</p>\n<h3>1. Take a case at backend</h3>\n<p>If you want to implement the <code>CRUD</code> features, the codes can be designed very simply, and you can even know how to use it without referencing the documents</p>\n<blockquote>\n<p>We can recall that most of the other backend MVC frameworks or backend API frameworks provide the <code>CRUD</code> features, while often stop there steps here?</p>\n</blockquote>\n<p>Then, let’s introduce some real business requirements:</p>\n<ol>\n<li>\n<p>Add a <code>draft</code> copy of the data. When we modify the <code>draft</code>, the original data that has been formally submitted will not be affected</p>\n</li>\n<li>\n<p>Add some <code>history</code> copies of the data, so as to record the historical version of the data</p>\n</li>\n<li>\n<p>Add a <code>approval workflow</code>. Business data will be approved after the draft is submitted, and will be transferred to the <code>formal</code> copy only after it is approved</p>\n</li>\n<li>\n<p>Add <code>cms static rendering mechanism</code>: as CRUD are generally managed in the backend, we need to output the data statically for the frontend system to access, and realize the SEO optimization of the website</p>\n</li>\n<li>\n<p>Add <code>category</code> and <code>tag</code> features to facilitate further classification of data</p>\n</li>\n<li>\n<p>For these characteristics mentioned above:</p>\n<ol>\n<li>\n<p>How to refine general concepts</p>\n</li>\n<li>\n<p>How to design the development interface (to achieve the effect of <code>out-of-the-box</code> and <code>flexible-customization</code>)</p>\n</li>\n<li>\n<p>How to configure flexibly (enable or disable some features conveniently). As the saying goes: it is easy to reduce dimensions, but difficult to increase dimensions. We need to have these features first, and then decide whether to enable them according to business requirements</p>\n</li>\n<li>\n<p>How to adapt more business scenarios (rather than only applicable to a certain type of business data), such as blog posts, community posts, leave forms, reimbursement forms, purchase orders, contracts, projects, assets, financial documents, etc.</p>\n</li>\n</ol>\n</li>\n<li>\n<p>It is doomed that the concept of business data is not simple, but CabloyJS has implemented a brief development interface, which can be used <code>out-of-the-box</code> and <code>flexible-customization</code></p>\n</li>\n</ol>\n<blockquote>\n<p>See Also：Bilibili Video：<a href=\"https://www.bilibili.com/video/BV1yL4y1w7dc/\">新建业务表单+审批工作流</a> (Translation Wanted)</p>\n</blockquote>\n<h3>2. Take a case at frontend</h3>\n<ol>\n<li>\n<p><code>Question</code>: With the popularization and upgrading of mobile devices, a large number of business scenarios need mobile support. Then, how can the admin management system support the mobile devices more elegantly?</p>\n</li>\n<li>\n<p><code>Traditional solution</code>: At present, most of the admin management frameworks on the market are compatible with PC and Mobile by using <code>CSS media query</code></p>\n<ol>\n<li><code>Disadvantages of the traditional solution</code>: However, the UI interaction experiences of PC and Mobile are different, and the page layouts are different either. Therefore, only relying on <code>CSS media query</code> can only make PC pages available on the Mobile, but it is far from achieving the effect of the native Mobile</li>\n</ol>\n</li>\n<li>\n<p><code>New solution</code>: CabloyJS provides a unique  adaptive layout of <code>pc=mobile+pad</code>, so that only one set of codes is needed to adapt to PC and mobile at the same time, and the mobile is close to the native interactive experience</p>\n<ol>\n<li><code>Advantages of the new solution</code>: This solution also implements the design principle of <code>out-of-the-box</code> + <code>flexible-customization</code>, with the style of <code>brief-but-not-simple</code>. All you need to do is to understand this mechanism by referencing documents or watching videos. The codes required for actual frontend page development will be much less than <code>CSS media query</code></li>\n</ol>\n</li>\n</ol>\n<blockquote>\n<p>See Also：Bilibili Video: <a href=\"https://www.bilibili.com/video/BV1St4y1j7kv/\">独树一帜的跨端方案：pc=mobile+pad自适应布局</a> (Translation Wanted)</p>\n</blockquote>\n<h2>Basic Concepts</h2>\n<p>It is recommended that you read the following documents to have a preliminary understanding of the basic concepts of CabloyJS</p>\n<ul>\n<li>\n<p><a href=\"https://cabloy.com/articles/guide-quick-start.html\">Quick Start</a></p>\n</li>\n<li>\n<p><a href=\"https://cabloy.com/articles/module-create.html\">Modularization And Create Module</a></p>\n</li>\n<li>\n<p><a href=\"https://cabloy.com/articles/module-compile.html\">Module Compilation and Publish</a></p>\n</li>\n</ul>\n<h2>Basic knowledges</h2>\n<p>CabloyJS is based on EggJS, VueJS and Framework7. These underlying framework documents do not have to be read first. CabloyJS provides enough samples and test codes to facilitate rapid development. It is recommended to run CabloyJS project first, and then gradually introduce relevant knowledge as needed</p>\n<p>Of course, if you have the knowledges of EggJS and Framework7 in advance, it is easier to understand what innovations and transformations CabloyJS has made on the basis of these two</p>\n<ul>\n<li>Frontend\n<ul>\n<li><a href=\"https://v2.vuejs.org/v2/guide/\">Vue2</a></li>\n<li><a href=\"https://v5.framework7.io/\">Framework7</a></li>\n</ul>\n</li>\n<li>Backend\n<ul>\n<li><a href=\"https://eggjs.org\">EggJS</a></li>\n</ul>\n</li>\n</ul>\n<h2>Learn through practice</h2>\n<p>CabloyJS has many built-in core modules, which encapsulates and implements most of the functions and features commonly used in specific businesses. Therefore, it is recommended that you first create a project, run it, and preview the functions and features provided by CabloyJS. In this way, when you develop your own system, you will know how to refer to the existing paradigm to get twice the result with half the effort</p>\n<ul>\n<li>See Also: <a href=\"https://cabloy.com/articles/guide-quick-start.html\">Quick Start</a></li>\n</ul>\n<h2>Free Video Courses</h2>\n<p>CabloyJS offers some free video courses. This set of courses is taught by the author of CabloyJS, zhennann. Through on-site coding and actual combat, it takes you into the real scene of NodeJS full stack development, so that you can quickly improve development skills and quickly start the development of various business systems after learning</p>\n<ul>\n<li>\n<p>See Also: <a href=\"https://course.cabloy.com/zh-cn/articles/A-001.html\">A-001: CabloyJS全栈框架：从入门到精通</a> (Translation Wanted)</p>\n</li>\n<li>\n<p>See Also: <a href=\"https://course.cabloy.com/zh-cn/articles/A-002.html\">A-002: CabloyJS全栈框架：功能特性演示</a> (Translation Wanted)</p>\n</li>\n<li>\n<p>See Also: <a href=\"https://course.cabloy.com/zh-cn/articles/B-001.html\">B-001: 微信一起点菜项目进度复盘</a> (Translation Wanted)</p>\n</li>\n</ul>\n<h2>Tutorials</h2>\n<p>On the basis of <code>CabloyJS</code> framework, it is very fast and convenient to redevelop specific business modules. From the following <code>tutorials</code> section, you can see what steps are needed to develop a <code>business module</code></p>\n<ul>\n<li>See Also: <a href=\"https://cabloy.com/articles/tutorial-introduce.html\">Tutorials</a></li>\n</ul>\n<h2>EggBornJS</h2>\n<p>By reading the <code>EggBornJS</code> section, you can understand what features <code>EggBornJS</code> has extended on the basis of <code>EggJS</code> in order to achieve <code>business modularity</code></p>\n<ul>\n<li>See Also: <a href=\"https://cabloy.com/articles/eggborn-introduce.html\">What is EggBornJS</a></li>\n</ul>\n<h2>CabloyJS</h2>\n<p>By reading the <code>CabloyJS</code> section, you can understand what core modules <code>CabloyJS</code> provides to improve the efficiency and convenience of business development</p>\n<ul>\n<li>See Also: <a href=\"https://cabloy.com/articles/cabloy-introduce.html\">What is CabloyJS</a></li>\n</ul>\n<h2>NodeJS Workflow Engine</h2>\n<p><code>NodeJS workflow engine</code> is the core component of a business development platform. By reading this chapter, you can understand how CabloyJS’s own workflow engine supports the development of business systems in a simple, flexible and efficient way</p>\n<ul>\n<li>See Also: <a href=\"https://cabloy.com/articles/flow-introduce.html\">What is NodeJS Workflow Engine</a></li>\n</ul>\n<h2>Solutions</h2>\n<p>Based on CabloyJS, corresponding solutions are implemented for different business scenarios, including:</p>\n<ol>\n<li>\n<p><a href=\"https://cabloy.com/articles/cms-introduce.html\">Cabloy-CMS</a></p>\n</li>\n<li>\n<p><a href=\"https://cabloy.com/articles/community-introduce.html\">Cabloy-Community</a></p>\n</li>\n<li>\n<p><a href=\"https://cabloy.com/zh-cn/articles/wechat-introduce.html\">Cabloy-Wechat</a> (Translation Wanted)</p>\n</li>\n<li>\n<p><a href=\"https://cabloy.com/zh-cn/articles/wxwork-introduce.html\">Cabloy-Wechat Work</a> (Translation Wanted)</p>\n</li>\n<li>\n<p><a href=\"https://cabloy.com/zh-cn/articles/dingtalk-introduce.html\">Cabloy-Dingtalk</a> (Translation Wanted)</p>\n</li>\n<li>\n<p><a href=\"https://cabloy.com/zh-cn/articles/uniapp-introduce.html\">Cabloy-Uniapp</a> (Translation Wanted)</p>\n</li>\n</ol>\n<h2>Test Modules/Suites</h2>\n<ul>\n<li>\n<p><code>test-party</code> : is the test suite of CabloyJS, including a large number of <code>test cases</code> and <code>Kitchen-sink</code></p>\n<ul>\n<li>See Also: <a href=\"https://store.cabloy.com/articles/test-party.html\">test-party</a></li>\n</ul>\n</li>\n<li>\n<p><code>test-flow</code>: is the test module of NodeJS workflow engine, containing a large number of workflow related test cases</p>\n<ul>\n<li>See Also: <a href=\"https://store.cabloy.com/articles/test-flow.html\">test-flow</a></li>\n</ul>\n</li>\n<li>\n<p><code>test-note</code>: is used to demonstrate how to use the Markdown rich text editor</p>\n<ul>\n<li>See Also: <a href=\"https://store.cabloy.com/articles/test-note.html\">test-note</a></li>\n</ul>\n</li>\n</ul>\n<p>These test <code>modules/suites</code> not only facilitate the quick learning of knowledge points in all aspects of CabloyJS, but also provide a large number of code examples to facilitate the rapid start of actual project development. It is strongly recommended that you pay attention to and keep these test <code>modules/suites</code> updated, so as to always obtain the latest sample codes in time</p>\n<ul>\n<li>\n<p>How to install test modules/suites, see also: <a href=\"https://cabloy.com/articles/cli-store.html\">Cabloy Store Cli</a></p>\n</li>\n<li>\n<p>How to disable test modules/suites, see also: <a href=\"https://cabloy.com/articles/disabled-modules.html\">Disable Module/Suite</a></p>\n</li>\n<li>\n<p>How to update test modules/suites, see also: <a href=\"https://cabloy.com/articles/update-cabloy.html\">Update Cabloy</a></p>\n</li>\n</ul>\n<h2>Core Modules</h2>\n<p>By reading the source codes of the core modules provided by <code>CabloyJS</code>, you will find that the <code>CabloyJS</code> framework is flexible enough to allow you to deeply customize, replace, and extend the numerous functions and features provided by <code>CabloyJS</code></p>\n<ul>\n<li>See Also: <a href=\"https://cabloy.com/articles/modules-list.html\">Core Modules</a></li>\n</ul>\n<h2>Contributions</h2>\n<p>Welcome to participate in and contribute to the improvement of the CabloyJS full stack framework, which is also an effective way to learn CabloyJS quickly and deeply</p>\n</div>",
    "title": "开发累了就摸个鱼🐟，帮我修改一下中式英语",
    "last_reply_at": "2023-05-06T09:43:52.829Z",
    "good": false,
    "top": false,
    "reply_count": 2,
    "visit_count": 2801,
    "create_at": "2022-11-28T07:00:08.577Z",
    "author": {
      "loginname": "zhennann",
      "avatar_url": "https://avatars.githubusercontent.com/u/24246985?v=4&s=120"
    }
  },
  {
    "id": "643ce45c6779ea3ac114dd16",
    "author_id": "54009f5ccd66f2eb37190485",
    "tab": "share",
    "content": "<div class=\"markdown-text\"><p>技术栈\n1、mysql\n2、react\n3、node框架（koa、fastify，midway）</p>\n<p>cool-admin我看过。其他，大家有啥好推荐吗？</p>\n<p>接下来打算基于midway，这样做。</p>\n<pre class=\"prettyprint\"><code>@Controller(&quot;&#x2F;posts&quot;)\n@Crud()\nexport class PostController extends BaseController&lt;PostService&gt;{\n\n}\n</code></pre></div>",
    "title": "最近找了一圈，没有一个好的crud，大家有啥好推荐吗？",
    "last_reply_at": "2023-05-06T07:47:45.199Z",
    "good": false,
    "top": false,
    "reply_count": 9,
    "visit_count": 2550,
    "create_at": "2023-04-17T06:17:00.775Z",
    "author": {
      "loginname": "i5ting",
      "avatar_url": "https://avatars.githubusercontent.com/u/3118295?v=4&s=120"
    }
  },
  {
    "id": "6436509e6779ea2a2d14da50",
    "author_id": "5d47c83b4f472f7fee152927",
    "tab": "ask",
    "content": "<div class=\"markdown-text\"><p>判断一个变量里存的 <strong>是否为基本数据类型</strong></p>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#primitive_values\">mdn 上说</a>:</p>\n<blockquote>\n<p>All primitive types, except null, can be tested by the typeof operator. typeof null returns “object”, so one has to use === null to test for null.</p>\n</blockquote>\n<p>那么可不可以这样：</p>\n<pre class=\"prettyprint language- js\"><code>function isPrimative(target) {\n  return typeof target != &#x27;object&#x27; &amp;&amp; typeof target != &#x27;function&#x27; || target === null\n}\n</code></pre><p>大家有没有想到什么反例，或更简洁的方式，感谢指导！</p>\n</div>",
    "title": "大家伙平时是怎么判断“基本数据类型”的？",
    "last_reply_at": "2023-05-04T07:39:22.464Z",
    "good": false,
    "top": false,
    "reply_count": 2,
    "visit_count": 2150,
    "create_at": "2023-04-12T06:33:02.466Z",
    "author": {
      "loginname": "daGaiGuanYu",
      "avatar_url": "https://avatars.githubusercontent.com/u/27003009?v=4&s=120"
    }
  },
  {
    "id": "6443a2996779ea019714e0f9",
    "author_id": "5c9dda1599e62a362ff412ef",
    "tab": "share",
    "content": "<div class=\"markdown-text\"><p>大家好，我是一位93年的前端开发者，最近开源了一款基于Fabric.js + Vue3 开发的Web图形编辑器，它是一个<strong>可以自定义设计模板、设计素材，让开发者快捷的开发出一个图片编辑应用</strong>，类似稿定设计、创客贴设计这样的工具。</p>\n<p>这篇笔记的两个目的：</p>\n<ol>\n<li>介绍开源项目，如果有类似场景大家可直接使用，不再重复开发。</li>\n<li>分享开源经历，鼓励和邀请对开源感兴趣的伙伴一起参与进来。</li>\n</ol>\n<h2>项目介绍</h2>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa746af9a6ee4b05984ae93d4eff989f~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"screenshot-20230415-142257.png\"></p>\n<p>Github：<a href=\"https://github.com/nihaojob/vue-fabric-editor\">https://github.com/nihaojob/vue-fabric-editor</a></p>\n<p>预览：<a href=\"https://nihaojob.github.io/vue-fabric-editor/\">https://nihaojob.github.io/vue-fabric-editor/</a></p>\n<h3></h3>\n<h3>技术选型：</h3>\n<p><strong>项目以Fabric.js 为底层，使用Vue3框架和精致的View UI Plus组件库构建</strong>。\nFabric.js 是业界知名的Canvas工具库，它已经12岁了，在业界得到了广泛的应用和认可；Vue提供更友好的入门曲线，尤其在国内应用更广；希望借助这些优秀的开源项目，<strong>构建底层强大、上手容易、便捷扩展、开箱即用的开源图像编辑器产品</strong>。</p>\n<h3>应用场景</h3>\n<p>它适用于**海报设计、封面设计、T恤设计、奖状/工卡设计、电子价签设计、印章设计、手机壁纸、PPT设计等场景，**还有更复杂的工业软件场景，如机房拓扑拓展、设备巡检图等。\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/867e54383ff847d7931e7cf9e6a04aff~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"image.png\">\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c5f1268b28694307b3cacc7c57bd3228~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"image.png\"></p>\n<h3>产品特点</h3>\n<p>开源前做了一些调研，已经有一些比较专业的开源编辑器项目，比如知名的SVGEdit项目，它们很强大，类似在线版本的PS，提供给更专业的设计师使用；<strong>vue-fabric-editor的产品定位是给非专业设计人员使用</strong>，例如让没有设计技能的运营同学在模板上简单修改，生成一张在公众号中使用的头图。\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2f004e7389ae47889a53f16afa815366~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"image.png\"></p>\n<h3>支持功能</h3>\n<ol>\n<li>支持导入导出JSON源文件，导出常见的图片PNG、SVG格式。</li>\n<li>可自定义设计模板、字体样式模板、自定义分类素材。</li>\n<li>元素支持拖拽、组合、层级管理、多种对齐操作。</li>\n<li>图片素材支持插入、替换、滤镜、裁剪。</li>\n<li>支持形状素材、线条绘制，渐变、边框、透明度、阴影设置。</li>\n<li>画布可自定义尺寸、放大缩小、辅助线、标尺功能。</li>\n<li>快捷键、右键菜单快捷操作设置。</li>\n</ol>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f372975619e64f09a619b4c94e7f5261~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"20230422131548_rec_.gif\"></p>\n<p>以上就是项目的介绍了，总结一下，<strong>它是一个基于Fabric + Vue3开发的一款开源Web图片编辑器，二次开发简单、扩展便捷、可帮助开发者快速构建一个面向非专业设计人员的图形编辑器</strong>。</p>\n<h2>开源经历</h2>\n<h3>关于我</h3>\n<p>我曾就职于优信二手车，参与过低代码平台的开发，现在一家互联网保险公司工作，参与音视频营销工具、外呼系统的开发，都属于复杂度比较高的前端项目，一直对架构和开源比较感兴趣，也在学习和积累设计模式、架构设计、开源相关的经验。\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4c025963d7a44b2791c64ed9c748262d~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"image.png\">\n作为一位已经30岁的开发者，<strong>一直对开源有着强烈的兴趣，但是从未参与过</strong>，于是在好奇心的驱动下发起了这个开源项目。</p>\n<h3>项目经历</h3>\n<p>最初，我帮朋友实现了一个基于Fabric.js开发的图片生成工具，后面将核心功能抽离并开源到了Github上，投稿到了阮一峰老师的博客，获得了一些关注。</p>\n<p>Fabric.js的底层能力非常强大，接口也很灵活，<strong>我最初以为只需要简单的API调用就可以实现一个图片编辑器</strong>，事实上我高估了自己的学习能力，也低估了Fabric.js的强大和灵活。</p>\n<p><strong>很多开发者反馈Fabric.js 的文档不太友好</strong>，太过强大和灵活也有一个弊端，那就是细节太多，要实现一个基础功能完整、功能丰富的图编辑器应用并不轻松，<strong>要掌握很多的细节，做很多基础的封装工作</strong>。</p>\n<p>我将开发过程发布到了技术社区，结识了很多Fabric.js的开发者。</p>\n<ol>\n<li><a href=\"https://juejin.cn/post/7155040639497797645\">《使用fabric.js 快速开发一个图片编辑器》</a></li>\n<li><a href=\"https://juejin.cn/post/7199849226745430076\">《fabric.js开发图片编辑器的细节实现》</a></li>\n<li><a href=\"https://juejin.cn/post/7222141882515128375\">《fabric.js开发图片编辑器可以实现哪些功能？》</a></li>\n</ol>\n<p>短短几个月的时间，项目**在Github上已经从0涨到1K+ Star，**开源给我带来了新奇的体验。\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b1695d59d38f4299bddd440984b6513e~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"image.png\"></p>\n<h3>沉淀</h3>\n<p>在和众多的开发者交流后，发现大家都在做同一件事情，重复的开发；大家更期望在<strong>不做太多基础工作的情况下，快速构建一个功能完整、易于扩展的图片编辑应用</strong>。</p>\n<p>目前的项目还只是一个前端应用项目，希望未来和社区一起沉淀一个介于Web图片编辑器应用与Fabric.js底层库之间的封装层，<strong>面向应用开发者设计，提供更简单的接口，让开发者可以通过开源SDK，快速构建图片编辑器应用</strong>。\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e6e8fec15d9844c1af2f2cdd8ba3084e~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"image.png\"></p>\n<h3>邀请</h3>\n<p>开源是很有魅力一件事情，我在Github上结识了很多志同道合的贡献者，<strong>他们是一个个富有热情且有执行力的有趣灵魂</strong>，是他们在深夜付出自己的时间与热爱为项目贡献代码，让不相识的后来人受益，让项目越来越好，<strong>我也从一个开源门外汉，和大家一起成为了开源贡献者</strong>。\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ecc79fefc06848a8bdae4b7d531d5356~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"image.png\">\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0df6172b6ca143a4a77e16dd87f6541f~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"image.png\"></p>\n<p>这是一个很新的项目和社区，有太多的工作需要做，<strong>如果你对这件事情感兴趣，真诚的邀请你加入，希望我们一起边走边学，在未来一起成为开源世界里的一部分，期待你的加入。</strong></p>\n</div>",
    "title": "我的开源项目与开源经历分享",
    "last_reply_at": "2023-04-22T09:02:17.673Z",
    "good": false,
    "top": false,
    "reply_count": 0,
    "visit_count": 1248,
    "create_at": "2023-04-22T09:02:17.673Z",
    "author": {
      "loginname": "nihaojob",
      "avatar_url": "https://avatars.githubusercontent.com/u/13534626?v=4&s=120"
    }
  },
  {
    "id": "643aab546779ea703c14dc96",
    "author_id": "550973933135610a365b01fa",
    "tab": "share",
    "content": "<div class=\"markdown-text\"><h2>关于helux</h2>\n<p><a href=\"https://github.com/tnfe/hel/tree/main/packages/helux\">helux</a>是一个鼓励服务注入，并支持响应式变更react的全新数据流方案，它的前身是<a href=\"https://github.com/concentjs/concent\">concent</a>（一个类vue开发体验的高性能状态管理框架），但concent自身因为需要兼容class和function保持一致的语法，且为了对其<code>setup</code>功能，导致内部代码量实在太大，压缩后有<code>70</code>多kb，api暴露得也非常多，导致学习难度急剧上升，为了更符合现在非常流行的<code>DDD</code>围绕业务概念构建领域模型的编码趋势，<code>helux</code>一开始就设计为<code>鼓励服务注入</code>、<code>支持响应式变更</code>、<code>支持依赖收集</code>的轻量级react数据流方案。</p>\n<p>它拥有以下优势：</p>\n<ul>\n<li>轻量，压缩后2kb</li>\n<li>简单，仅暴露7个api，高频使用的仅<code>createShared</code>、<code>useObject</code>、<code>useSharedObject</code>、<code>useService</code>4个接口</li>\n<li>高性能，自带依赖收集</li>\n<li>响应式，支持创建响应式对象，在视图之外变更对象将同步更新视图</li>\n<li>服务注入，配合<code>useService</code>接口轻松控制复杂业务逻辑，总是返回稳定的引用，可完全避免<code>useCallback</code>依赖烦扰了</li>\n<li>状态提升0改动，所以地方仅需将<code>useObject</code>换为<code>useSharedObject</code>即可提升状态共享到其他组件</li>\n<li>避免forwordRef 地狱，内置的<code>exposeService</code>模式将轻松解决父掉子时的<code>ref</code>转发晦涩理解问题和传染性（隔代组件需要层层转发）</li>\n<li>ts友好，100% ts 编写，为你提供全方位类型提示</li>\n</ul>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/88176d2bc14643e8b81d29fd72902a9d~tplv-k3u1fbpfcp-watermark.image?\" alt=\"2.gif\"></p>\n<blockquote>\n<p>该gif图和以下所有api均对应有在线<a href=\"https://codesandbox.io/s/demo-show-service-dev-mode-ikybly?file=/src/App.tsx\">示例1</a>和<a href=\"https://codesandbox.io/p/sandbox/use-service-to-replace-ref-e5mgr4?file=%2Fsrc%2FApp.tsx\">示例2</a>,欢迎fork并修改体验。</p>\n</blockquote>\n<p>为什么起名<code>helux</code>，虽然内心上我是把它作为<code>concent</code> v3版本去开发的，但因为它的变化实在太大，除了依赖收集不继承任何<code>concent</code>的特性，同时它也是伴随我开发的<a href=\"https://github.com/tnfe/hel\">hel-micro</a>诞生一款作品，我期望它成为 hel-micro 生态的 luxury 级别的贡献，就将 hel-micro 和 luxury 两个词拼一起成为了 <code>helux</code>。</p>\n<p>欢迎点星关注<a href=\"https://github.com/tnfe/hel/tree/main/packages/helux\">helux</a>，它虽然较新，但已在我自己的使用场景中发挥功不可没的作用，现已加入hel-micro生态大仓，期待能成为你愿意挑选的一款可心数据流方案。</p>\n<h2>快速上手</h2>\n<p>极致的简单是helux最大的优势，了解以下6个api后，你可以轻松应付任何复杂场景，最大的魅力在于<code>useSharedObject</code>和<code>useService</code>两个接口，且看如下api介绍，或访问在线<a href=\"https://codesandbox.io/s/demo-show-service-dev-mode-ikybly?file=/src/App.tsx\">示例1</a>和<a href=\"https://codesandbox.io/p/sandbox/use-service-to-replace-ref-e5mgr4?file=%2Fsrc%2FApp.tsx\">示例2</a>fork并修改来体验。</p>\n<h3>useObject</h3>\n<p>使用 useObject 有两个好处</p>\n<ul>\n<li>1 方便定义多个状态值时，少写很多 useState</li>\n<li>2 内部做了 unmount 判断，让异步函数也可以安全的调用 setState，避免 react 出现警告 :\n“Called SetState() on an Unmounted Component” Errors</li>\n</ul>\n<pre class=\"prettyprint language-ts\"><code>&#x2F;&#x2F; 基于对象初始化一个视图状态\nconst [state, setState] = useObject({a:1});\n&#x2F;&#x2F; 基于函数初始化一个视图状态\nconst [state, setState] = useObject(()=&gt;({a:1}));\n</code></pre><h3>useForceUpdate</h3>\n<p>强制更新当前组件视图，某些特殊的场景可以使用它来做视图重刷新</p>\n<pre class=\"prettyprint language-ts\"><code>const forUpdate = useForceUpdate();\n</code></pre><h3>createSharedObject</h3>\n<p>创建一个共享对象，可透传给 <code>useSharedObject</code>，具体使用见 useSharedObject</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 初始化一个共享对象\nconst sharedObj = createSharedObject({a:1, b:2});\n&#x2F;&#x2F; 基于函数初始化一个共享对象\nconst sharedObj = createSharedObject(()=&gt;({a:1, b:2}));\n</code></pre><h3>createReactiveSharedObject</h3>\n<p>创建一个响应式的共享对象，可透传给 useSharedObject</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 初始化一个共享对象\nconst [reactiveObj, setState] = createReactiveSharedObject({a:1, b:2});\n\nsharedObj.a = 111; &#x2F;&#x2F; 任意地方修改 a 属性，触发视图渲染\nsetSharedObj({a: 111}); &#x2F;&#x2F; 使用此方法修改 a 属性，同样也能触发视图渲染，深层次的数据修改可使用此方法\n</code></pre><h3>createShared</h3>\n<p>函数签名</p>\n<pre class=\"prettyprint\"><code>function createShared&lt;T extends Dict = Dict&gt;(\n  rawState: T | (() =&gt; T),\n  enableReactive?: boolean,\n): {\n  state: SharedObject&lt;T&gt;;\n  call: &lt;A extends any[] = any[]&gt;(\n    srvFn: (ctx: { args: A; state: T; setState: (partialState: Partial&lt;T&gt;) =&gt; void }) =&gt; Promise&lt;Partial&lt;T&gt;&gt; | Partial&lt;T&gt; | void,\n    ...args: A\n  ) =&gt; void;\n  setState: (partialState: Partial&lt;T&gt;) =&gt; void;\n};\n</code></pre><p>创建一个响应式的共享对象，可透传给 useSharedObject，它是<code>createReactiveSharedObject</code>和<code>createSharedObject</code>的结合体，当需要调用脱离函数上下文的服务函数时（即不需要感知组件props时），可使用该接口，第二位参数为是否创建响应式状态，为 true 时效果同 <code>createReactiveSharedObject</code> 返回的 sharedObj</p>\n<pre class=\"prettyprint\"><code> const ret = createShared({ a: 100, b: 2 });\n const ret2 = createShared({ a: 100, b: 2 }, true); &#x2F;&#x2F; 创建响应式状态\n &#x2F;&#x2F; ret.state 可透传给 useSharedObject\n &#x2F;&#x2F; ret.setState 可以直接修改状态\n &#x2F;&#x2F; ret.call 可以调用服务函数，并透传上下文\n</code></pre><p>以下将举例两种具体的定义服务函数的方式，之后用户便可在其他其他地方任意调用这些服务函数修改共享状态了，如需感知组件上下文，则需要用到下面介绍的<code>useService</code>接口去定义服务函数。</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 调用服务函数第一种方式，直接调用定义的函数，配合 ret.setState 修改状态\nfunction changeAv2(a: number, b: number) {\n   ret.setState({ a, b });\n}\n*\n&#x2F;&#x2F; 第二种方式，使用 ret.call(srvFn, ...args) 调用定义在call函数参数第一位的服务函数\nfunction changeA(a: number, b: number) {\n   ret.call(async function (ctx) { &#x2F;&#x2F; ctx 即是透传的调用上下文，\n     &#x2F;&#x2F; args：使用 call 调用函数时透传的参数列表，state：状态，setState：更新状态句柄\n     &#x2F;&#x2F; 此处可全部感知到具体的类型\n     &#x2F;&#x2F; const { args, state, setState } = ctx;\n     return { a, b };\n   }, a, b);\n }\n</code></pre><h3>useSharedObject</h3>\n<p>函数签名</p>\n<pre class=\"prettyprint\"><code>function useSharedObject&lt;T extends Dict = Dict&gt;(sharedObject: T, enableReactive?: boolean): [\n  SharedObject&lt;T&gt;,\n  (partialState: Partial&lt;T&gt;) =&gt; void,\n]\n</code></pre><p>接收一个共享对象，多个视图里将共享此对象，内部有依赖收集机制，不依赖到的数据变更将不会影响当前组件更新</p>\n<pre class=\"prettyprint language-ts\"><code>const [ obj, setObj ] = useSharedObject(sharedObj);\n</code></pre><p><code>useSharedObject</code>默认返回非响应式状态，如需要使用响应式状态，透传第二位参数为true即可</p>\n<pre class=\"prettyprint language-ts\"><code>const [ obj, setObj ] = useSharedObject(sharedObj);\n&#x2F;&#x2F; now obj is reactive\n setInterval(()=&gt;{\n  state.a = Date.now(); &#x2F;&#x2F; 触发视图更新\n }, 2000);\n</code></pre><h3>useService</h3>\n<p>函数签名</p>\n<pre class=\"prettyprint\"><code>&#x2F;**\n * 使用用服务模式开发 react 组件：\n * @param compCtx\n * @param serviceImpl\n *&#x2F;\nfunction useService&lt;P extends Dict = Dict, S extends Dict = Dict, T extends Dict = Dict&gt;(\n  compCtx: {\n    props: P;\n    state: S;\n    setState: (partialState: Partial&lt;S&gt;) =&gt; void;\n  },\n  serviceImpl: T,\n): T &amp; {\n  ctx: {\n    setState: (partialState: Partial&lt;S&gt;) =&gt; void;\n    getState: () =&gt; S;\n    getProps: () =&gt; P;\n  };\n}\n</code></pre><p>它可搭配<code>useObject</code>和<code>useSharedObject</code>一起使用，会创建服务对象并返回，该服务对象是一个稳定的引用，且它包含的所有方法也是稳定的引用，可安全方法交给其它组件且不会破会组件的pros比较规则，避免烦恼的<code>useMemo</code>和<code>useCallback</code>遗漏相关依赖</p>\n<p>搭配<code>useObject</code>时</p>\n<pre class=\"prettyprint language-ts\"><code>function DemoUseService(props: any) {\n  const [state, setState] = useObject({ a: 100, b: 2 );\n  &#x2F;&#x2F; srv本身和它包含的方法是一个稳定的引用，\n  &#x2F;&#x2F; 可安全的将 srv.change 方法交给其它组件且不会破会组件的pros比较规则\n  const srv = useService({ props, state, setState }, {\n    change(a: number) {\n      srv.ctx.setState({ a });\n    },\n  });\n  \n  return &lt;div&gt;\n    DemoUseService:\n    &lt;button onClick={() =&gt; srv.change(Date.now())}&gt;change a&lt;&#x2F;button&gt;\n  &lt;&#x2F;div&gt;;\n}\n</code></pre><p>搭配<code>useSharedObject</code>时，只需替换<code>useObject</code>即可，其他代码不用做任何改变</p>\n<pre class=\"prettyprint language-diff\"><code>+ const sharedObj = createSharedObject({a:100, b:2})\n\nfunction DemoUseService(props: any) {\n-  const [state, setState] = useObject({ a: 100, b: 2 );\n+  const [state, setState] = useSharedObject(sharedObj);\n</code></pre><h4>getState 和 getProps</h4>\n<p>因 <code>state</code> 和 <code>props</code> 是不稳定的，所以服务内部函数取的时候需从<code>srv.ctx.getState</code>或<code>srv.ctx.getProps</code></p>\n<pre class=\"prettyprint language-ts\"><code>&#x2F;&#x2F; 抽象服务函数\nexport function useChildService(compCtx: {\n  props: IProps;\n  state: S;\n  setState: (partialState: Partial&lt;S&gt;) =&gt; void;\n}) {\n  const srv = useService&lt;IProps, S&gt;(compCtx, {\n    change(label: string) {\n      &#x2F;&#x2F; !!! do not use compCtx.state or compCtx.state due to closure trap\n      &#x2F;&#x2F; console.log(&quot;expired state:&quot;, compCtx.state.label);\n\n      &#x2F;&#x2F; get latest state\n      const state = srv.ctx.getState();\n      console.log(&quot;the latest label in state:&quot;, state.label);\n      &#x2F;&#x2F; get latest props\n      const props = srv.ctx.getProps();\n      console.log(&quot;the latest props when calling change&quot;, props);\n\n      &#x2F;&#x2F; your logic\n      compCtx.setState({ label });\n    }\n  });\n  return srv;\n}\n\nexport function ChildComp(props: IProps) {\n  const [state, setState] = useObject(initFn);\n  const srv = useChildService({ props, state, setState });\n}\n\n return (\n    &lt;div&gt;\n      i am child &lt;br &#x2F;&gt;\n      &lt;button onClick={() =&gt; srv.change(&#96;self:${Date.now()}&#96;)}&gt;\n        change by myself\n      &lt;&#x2F;button&gt;\n      &lt;h1&gt;{state.label}&lt;&#x2F;h1&gt;;\n    &lt;&#x2F;div&gt;\n  );\n</code></pre><h4>exposeService</h4>\n<p>当孩子组件props上透传了<code>exposeService</code>函数时，<code>useService</code> 将自动透传服务对象给父亲组件，是一种比较方便的逃离<code>forwardRef</code>完成父调子的模式</p>\n<pre class=\"prettyprint language-ts\"><code>import { ChildSrv, Child } from &quot;.&#x2F;Child&quot;;\n\nfunction App() {\n  &#x2F;&#x2F; 保存孩子的服务\n  const childSrv = React.useRef&lt;{ srv?: ChildSrv }&gt;({});\n  const seeState = () =&gt; {\n    console.log(&quot;seeState&quot;, childSrv.current.srv?.ctx.getState());\n  };\n\n  return (\n    &lt;div&gt;\n      &lt;button onClick={() =&gt; childSrv.current.srv?.change(&#96;${Date.now()}&#96;)}&gt;\n        call child logic\n      &lt;&#x2F;button&gt;\n      &lt;Child\n        unstableProp={&#96;${Date.now()}&#96;}\n        exposeService={(srv) =&gt; (childSrv.current.srv = srv)}\n      &#x2F;&gt;\n    &lt;&#x2F;div&gt;\n  );\n}\n</code></pre><h2>结语</h2>\n<p><a href=\"https://github.com/tnfe/hel/tree/main/packages/helux\">helux</a>是把<a href=\"https://github.com/concentjs/concent\">concent</a>内部精华全部萃取提炼再加工后的全新作品，期望能得到你的喜欢与鼓励。❤️</p>\n</div>",
    "title": "helux，一个鼓励服务注入的响应式react状态库",
    "last_reply_at": "2023-04-15T13:49:08.460Z",
    "good": false,
    "top": false,
    "reply_count": 0,
    "visit_count": 1204,
    "create_at": "2023-04-15T13:49:08.460Z",
    "author": {
      "loginname": "fantasticsoul",
      "avatar_url": "https://avatars.githubusercontent.com/u/7334950?v=4&s=120"
    }
  },
  {
    "id": "643a5cd46779eac53714dc7d",
    "author_id": "5c9dda1599e62a362ff412ef",
    "tab": "share",
    "content": "<div class=\"markdown-text\"><p>最近使用fabric.js开发了一个图形编辑器并开源了，已收到900+star，<strong>很多开发者咨询fabric.js能实现哪些功能</strong>，今天就用文字加动图的形式直观的分享出来，帮助大家做参考。</p>\n<p>fabric.js 提供强大的底层能力，可实现<strong>自定义模板、素材、字体，图片滤镜、辅助线、组合、裁剪等功能，也提供了自定义元素等高级的用法</strong>。</p>\n<p>项目：<a href=\"https://github.com/nihaojob/vue-fabric-editor\">https://github.com/nihaojob/vue-fabric-editor</a></p>\n<p>预览：<a href=\"https://nihaojob.github.io/vue-fabric-editor/#/\">https://nihaojob.github.io/vue-fabric-editor/#/</a></p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89169a52052245839413826e3a9b9ac0~tplv-k3u1fbpfcp-watermark.image?\" alt=\"screenshot-20230415-142257.png\"></p>\n<h2>画布功能</h2>\n<p><strong>画布属性：尺寸、预设大小、背景色。</strong>\n支持修改画布尺寸，也有预常用预设的画布尺寸，可以便捷设置，有背景色修改属性，同时提供常用颜色的快捷修改。\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/044e2d09049f489f9341263862674fb9~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"20230415120741_rec_.gif\"></p>\n<p><strong>画布缩放：放大、缩小、自动适应、鼠标滚轮缩放。</strong>\n支持画布放大缩小操作，可按照1:1尺寸展示或自适应展示，页面窗口改变时会根据窗口大小自适应展示；滑动鼠标滚轮时可快捷缩放画布。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6950ef15074c494e9d277a5b46c2c9f2~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"20230415121804_rec_.gif\"></p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/570f0c1bb2434593949b65234972f1b4~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"20230415122049_rec_.gif\"></p>\n<p><strong>其他细节：拖拽画布、画布区域外显示控制条。</strong>\n画布支持拖拽操作，按住alt快捷键，可以拖动画布；当元素拖拽到画布外区域时，仍然展示控制条，但元素并不会被展示出来，所见即所得。\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b050ef702a4449dbce41b27a525a7e2~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"20230415122246_rec_.gif\"></p>\n<h2>辅助功能</h2>\n<p><strong>控制条：</strong> 在满足元素缩放、旋转的基础上尽量让其简洁，提供了2种样式。\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/69bba9a276e24db99653513bafb23f75~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"20230415123406_rec_.gif\"></p>\n<p><strong>标尺：</strong> 标尺与辅助线可以满足我们更高要求的设计场景。\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3489af30b75e4ecdbd037f7dddfbd10a~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"20230415123622_rec_.gif\"></p>\n<p><strong>快捷调整：</strong> 图层管理、右键菜单、快捷键。\n图层可以直观的定位元素的层级顺序，右键菜单提供了常用的快捷功能，还支持复制、删除等快捷键操作，提高操作效率。\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/559b2176cb3e4ce0bc973d27cd58d705~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"20230415125124_rec_.gif\"></p>\n<h2>基础元素</h2>\n<p><strong>字体元素：</strong> 字体元素有普通字体、框字体，框字体可调整外边框，自动换行。\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8b2dd53747534bbba5273787cced287a~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"20230415130158_rec_.gif\"></p>\n<p><strong>基础形状：</strong> 有矩形、圆形、三角形、多边形，可直接点击或拖拽添加到画布。\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cafa5a10f62049cdbd7a6f0d10760e29~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"20230415130303_rec_.gif\"></p>\n<p><strong>线条元素：</strong> 支持箭头、线条元素绘制。\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1209cdaee70b4f38b7eef8987d6d676d~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"20230415131152_rec_.gif\"></p>\n<p><strong>插入元素：</strong> 支持插入多种图片类型，图片图片、SVG元素、SVG字符串。\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba18715bb24d46719d8883a90d127152~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"20230415130901_rec_.gif\"></p>\n<p><strong>自定义素材：</strong> 素材在左侧分类展示，可定义图片素材、字体样式素材。\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c97231aaa1f145f1965c1a7ee935e442~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"20230415131012_rec_.gif\"></p>\n<h2>文件功能</h2>\n<p><strong>数据保存：</strong> 支持导出/导出JSON文件方便存储数据，可自定义设计模板。\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ff449fe3b9b4f08b5e51f5072b164ae~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"20230415131754_rec_.gif\"></p>\n<p><strong>图片保存：</strong> 可清空画布、预览图片、保存图片文件。\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dd9b6eef8f2d46a284acccaa15710f39~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"20230415131852_rec_.gif\"></p>\n<h2>属性设置</h2>\n<p><strong>基础操作：</strong> 所有元素都可以在属性面板调整透明度、坐标、旋转角度。\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/457b96af734d4a03bfeb003de4d04865~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"20230415133918_rec_.gif\"></p>\n<p><strong>锁定与组合：</strong> 锁定元素后元素将不会收到其他操作影响；可将多个元素组合为一个组元素，也可以将组元素拆分为多个元素。\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ed1d836659d849d0ba115a5ec2e3b959~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"20230415132328_rec_.gif\"></p>\n<p><strong>元素对齐：</strong> 单个元素支持相对于画布的水平、垂直、水平垂直居中，多个元素支持上、下、左、右对齐，水平居中、垂直居中、垂直平均分布、水平平均分布功能。\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b71eae7cab77489d8ffb51edb3c66f11~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"20230415132516_rec_.gif\">\n**自定义字体：**可自定义字体、对齐方式、行高、背景色、下划线、删除线等信息。\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4eae4c5d03474d28b25fa64e82ef87e4~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"image.png\"></p>\n<p><strong>渐变配置：</strong> 渐变是设计的重要形式之一，支持为元素、字体设置渐变颜色。\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/daf12add8983481cb2a11bcd0a33614e~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"image.png\"></p>\n<p><strong>边框设置：</strong> 支持为元素增加边框样式。\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/349ce94cbc0f4aae99ec59d72ea73346~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"20230415134137_rec_.gif\"></p>\n<p><strong>图片操作：</strong> 快捷替换、简单滤镜、复杂滤镜。\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4998294d7f11404fad58321bfb4f22ae~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"20230415133617_rec_.gif\"></p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f21f01ec7ccd40458693d0e0b8cb43a7~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"20230415133505_rec_.gif\"></p>\n<h2>总结</h2>\n<p>fabric.js 的底层能力非常强大，这依赖于灵活的底层接口，但是太过灵活也有一个弊端，那就是我们必须掌握更多的细节才能用起来得心应手，这对于开发者来说并不会太轻松。</p>\n<p><a href=\"https://github.com/nihaojob/vue-fabric-editor\">vue-fabric-editor</a>项目致力于打造一个开箱即用的web图片编辑器应用，同时<strong>沉淀一个介于web图片编辑器应用与fabric.js之间的封装层</strong>，期望封装层面向开发者设计，<strong>提供更简单的接口，让开发者可以轻松的实现图片应用开发</strong>。</p>\n<h2>邀请</h2>\n<p>通过技术社区和开源的方式和大家相识是一种很奇妙的体验，大部分都是在使用fabric.js做项目的开发者，我们组建了fabric.js开发者交流群，一起抱团取暖互相支招，一边吐槽文档，一起实现功能，欢迎你的加入交流群。</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e358ff17a16e4f6e946291c7beeac0d4~tplv-k3u1fbpfcp-watermark.image?\" alt=\"WechatIMG391.jpeg\"></p>\n<p>我们离目标还有很长的距离，如果你对这件事情感兴趣，真诚的邀请你加入，我们一起沉淀fabric.js的最佳实践，<strong>你会得到包括不限于以下列表的收获，你只要会简单的Git和Javascript语法就可以</strong>。</p>\n<ul>\n<li>熟悉开源协作方式，成为项目贡献者。</li>\n<li>Vue3 + TS实践，边学边开发。</li>\n<li>fabric.js开发，边学边开发。</li>\n<li>入门单元测试，边学边开发。</li>\n<li>众多的fabric.js开发者交流。</li>\n</ul>\n<p>我自己是第一次搞开源项目，感谢项目的贡献者的帮助和社区的推动，<strong>这是一个很新的项目和社区，期待你的加入，希望我们一起边走边学，在未来一起成为知名开源项目的开发者</strong>。</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f7d96501901c48c8ba76d6a64ca4a185~tplv-k3u1fbpfcp-watermark.image?\" alt=\"海报.png\"></p>\n</div>",
    "title": "fabric.js开发图片编辑器可以实现哪些功能？多图",
    "last_reply_at": "2023-04-15T08:14:12.595Z",
    "good": false,
    "top": false,
    "reply_count": 0,
    "visit_count": 1172,
    "create_at": "2023-04-15T08:14:12.595Z",
    "author": {
      "loginname": "nihaojob",
      "avatar_url": "https://avatars.githubusercontent.com/u/13534626?v=4&s=120"
    }
  },
  {
    "id": "634cc65ed3061fca39e88a56",
    "author_id": "5c9dda1599e62a362ff412ef",
    "tab": "share",
    "content": "<div class=\"markdown-text\"><p>最近自己开发了一个图片编辑器，把源码也放在了GitHub上，顺便也总结下使用fabric.js开发一个编辑器需要用到哪些知识点。</p>\n<ul>\n<li>预览地址：<a href=\"https://nihaojob.github.io/vue-fabric-editor/\">https://nihaojob.github.io/vue-fabric-editor/</a></li>\n<li>GitHub地址：<a href=\"https://github.com/nihaojob/vue-fabric-editor\">https://github.com/nihaojob/vue-fabric-editor</a></li>\n</ul>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/88ca4329b4c24dcea91e624ccadf4127~tplv-k3u1fbpfcp-watermark.image?\" alt=\"Foxmail20220904011310.png\"></p>\n<h3>架构设计</h3>\n<p><strong>选型：</strong> fabric.js 和 konva.js都是强大的canvas库，功能上类似，konva.js比较新中文文档也多一些，因为比较熟悉fabric就没有采用konva。</p>\n<p><strong>要点：</strong> 因为框架用的vue，主要解决如何把fabric的实例对象共享给各个功能组件，区分出是未选中、单选、多选状态，然后将选中、取消选中事件暴露给各个功能组件，子组件根据状态进行独立的功能开发。</p>\n<p>我的方法是在入口文件中初始化实例，然后与mixins结合，在mixins中定义了选择类型（多选、单选、未选中）、选中元素类型、选中id等属性，以及选中、取消选中的事件，子组件通过引入mixins来开发对应功能；如子组件需要对fabric对象进行操作，则可以通过inject获得原始对象。</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/97d79b361a2549eea30d199e59b36344~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\"></p>\n<p>入口文件：\n<a href=\"https://github.com/nihaojob/vue-fabric-editor/blob/161faae7b0adcf6f55d9efaa38cb6d7c6d2c01b5/src/views/HomeView.vue#L113\">https://github.com/nihaojob/vue-fabric-editor/blob/161faae7b0adcf6f55d9efaa38cb6d7c6d2c01b5/src/views/HomeView.vue#L113</a></p>\n<p>mixins文件：\n<a href=\"https://github.com/nihaojob/vue-fabric-editor/blob/main/src/mixins/select.js\">https://github.com/nihaojob/vue-fabric-editor/blob/main/src/mixins/select.js</a></p>\n<h3>初始化</h3>\n<p>初始化比较简单，fabric.js创建对象，用EventEmitter创建事件发射器，可订阅单选、多选、取消选择事件。\n通过vue的provide语法把fabric对象、EventEmitter对象向下传递，在mixins中保存选中的元素和选中状态。</p>\n<p><strong>初始化：</strong>\n<a href=\"https://github.com/nihaojob/vue-fabric-editor/blob/161faae7b0adcf6f55d9efaa38cb6d7c6d2c01b5/src/views/HomeView.vue#L111\">https://github.com/nihaojob/vue-fabric-editor/blob/161faae7b0adcf6f55d9efaa38cb6d7c6d2c01b5/src/views/HomeView.vue#L111</a></p>\n<p><strong>事件发射器：</strong></p>\n<pre class=\"prettyprint\"><code>import EventEmitter from &#x27;events&#x27;\n\nclass EventHandle extends EventEmitter {\n\n    init(handler){\n        this.handler = handler\n        this.handler.on(&quot;selection:created&quot;, (e) =&gt; this._selected(e));\n        this.handler.on(&quot;selection:updated&quot;,  (e) =&gt; this._selected(e));\n        this.handler.on(&quot;selection:cleared&quot;, (e) =&gt; this._selected(e));\n    }\n\n    &#x2F;&#x2F; 暴露单选多选事件\n    _selected(e) {\n        const actives = this.handler.getActiveObjects()\n        if(actives &amp;&amp; actives.length === 1) {\n            this.emit(&#x27;selectOne&#x27;, actives)\n        }else if(actives &amp;&amp; actives.length &gt; 1){\n            this.mSelectMode = &#x27;multiple&#x27;\n            this.emit(&#x27;selectMultiple&#x27;, actives)\n        }else{\n            this.emit(&#x27;selectCancel&#x27;)\n        }\n    }\n}\n\nexport default EventHandle\n</code></pre><p><strong>mixins:</strong></p>\n<pre class=\"prettyprint\"><code>export default {\n  inject: [&#x27;canvas&#x27;, &#x27;fabric&#x27;, &#x27;event&#x27;],\n  data() {\n    return {\n      mSelectMode: &#x27;&#x27;, &#x2F;&#x2F; one | multiple\n      mSelectOneType: &#x27;&#x27;, &#x2F;&#x2F; i-text | group ...\n      mSelectId: &#x27;&#x27;, &#x2F;&#x2F; 选择id\n      mSelectIds: [], &#x2F;&#x2F; 选择id\n    }\n  },\n  created(){\n    this.event.on(&#x27;selectOne&#x27;, (e) =&gt; {\n      this.mSelectMode = &#x27;one&#x27;\n      this.mSelectId = e[0].id\n      this.mSelectOneType = e[0].type\n      this.mSelectIds = e.map(item =&gt; item.id)\n    })\n\n    this.event.on(&#x27;selectMultiple&#x27;, (e) =&gt; {\n      this.mSelectMode = &#x27;multiple&#x27;\n      this.mSelectId = &#x27;&#x27;\n      this.mSelectIds = e.map(item =&gt; item.id)\n    })\n\n    this.event.on(&#x27;selectCancel&#x27;, () =&gt; {\n      this.mSelectId = &#x27;&#x27;\n      this.mSelectIds = []\n      this.mSelectMode = &#x27;&#x27;\n      this.mSelectOneType = &#x27;&#x27;\n    })\n  },\n  methods: {\n    &#x2F;**\n     * @description: 保存data数据\n     * @param {Object} data 房间详情数据\n     *&#x2F;\n    _mixinSelected({ event, selected }) {\n      if(selected.length === 1) {\n        const selectItem = selected[0]\n        this.mSelectMode = &#x27;one&#x27;\n        this.mSelectOneType = selectItem.type\n        this.mSelectId = [selectItem.id]\n        this.mSelectActive = [selectItem]\n      }else if(selected.length &gt; 1){\n        this.mSelectMode = &#x27;multiple&#x27;\n        this.mSelectActive = selected\n        this.mSelectId = selected.map(item =&gt; item.id)\n      }else{\n        this._mixinCancel()\n      }\n    },\n    &#x2F;**\n     * @description: 保存data数据\n     * @param {Object} data 房间详情数据\n     *&#x2F;\n     _mixinCancel(data) {\n      this.mSelectMode =&#x27;&#x27;\n      this.mSelectId= []\n      this.mSelectActive =[]\n      this.mSelectOneType = &#x27;&#x27;\n    },\n  }\n}\n\n</code></pre><h3>背景设置</h3>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2286f31ad81545579f8a0a4caf060d60~tplv-k3u1fbpfcp-watermark.image?\" alt=\"背景.gif\">\n主要包括设置画布大小、设置背景颜色、设置背景图片，也可以设置背景重复方向。\n<a href=\"https://github.com/nihaojob/vue-fabric-editor/blob/main/src/components/bgBar.vue\">代码：</a></p>\n<pre class=\"prettyprint language-\"><code>&#x2F;&#x2F; 设置大小\nsetSize() {\n      this.canvas.c.setWidth(this.width);\n      this.canvas.c.setHeight(this.height);\n      this.canvas.c.renderAll()\n},\n&#x2F;&#x2F; 设置背景图片\nsetBgImg(target) {\n      const imgEl = target.cloneNode(true);\n      imgEl.onload = () =&gt; {\n        &#x2F;&#x2F; 可跨域设置\n        const imgInstance = new this.fabric.Image(imgEl, { crossOrigin: &#x27;anonymous&#x27; });\n        &#x2F;&#x2F; 渲染背景\n        this.canvas.c.setBackgroundImage(imgInstance, this.canvas.c.renderAll.bind(this.canvas.c), {\n          scaleX: this.canvas.c.width &#x2F; imgInstance.width,\n          scaleY: this.canvas.c.width &#x2F; imgInstance.width,\n        });\n        this.canvas.c.renderAll()\n        this.canvas.c.requestRenderAll();\n      }\n},\n&#x2F;&#x2F; 背景颜色设置\nsetColor(color) {\n      this.canvas.c.setBackgroundColor(color, this.canvas.c.renderAll.bind(this.canvas.c))\n      this.canvas.c.backgroundImage = &#x27;&#x27;\n      this.canvas.c.renderAll()\n}\n</code></pre><h3>插入元素</h3>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/43d110915d044f91818a238df07bf767~tplv-k3u1fbpfcp-watermark.image?\" alt=\"插入元素.gif\">\n主要包括插入基础元素文字、正方形、圆形、三角形、SVG元素，详见<a href=\"https://github.com/nihaojob/vue-fabric-editor/blob/main/src/components/tools.vue#L122\">代码</a>：</p>\n<pre class=\"prettyprint\"><code>addText() {\n      const text = new this.fabric.IText(&#x27;万事大吉&#x27;, {\n        ...defaultPosition,\n        fontSize: 40, id: uuid(),\n      });\n      this.canvas.c.add(text)\n      this.canvas.c.setActiveObject(text);\n},\naddTriangle() {\n      const triangle = new this.fabric.Triangle({\n        top: 100,\n        left: 100,\n        width: 100,\n        height: 100,\n        fill: &#x27;#92706B&#x27;\n      })\n      this.canvas.c.add(triangle)\n      this.canvas.c.setActiveObject(triangle);\n},\n</code></pre><p>导入SVG元素时，可以导入SVG文件或者字符串进行导入，调用fabric的loadSVGFromURL、loadSVGFromString方法进行导入，<a href=\"https://github.com/nihaojob/vue-fabric-editor/blob/main/src/components/importSvg.vue\">详见代码</a>。</p>\n<h3>属性调整</h3>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e780a1c7c0414f0896bf80ca69b4a35c~tplv-k3u1fbpfcp-watermark.image?\" alt=\"属性调整.gif\">\n不同元素的属性会有差异，但通用属性是一致的，如填充颜色、坐标、旋转角度、透明度等，也有很多特定元素的特定属性，如文字的字体属性、图片的滤镜属性等，<a href=\"https://github.com/nihaojob/vue-fabric-editor/blob/main/src/components/attribute.vue\">详见代码</a>。\n字体属性可以自定义字体，需要先下载字体后再进行设置，可以通过fontfaceobserver工具库下载指定字体，成功后在设置字体名称。</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 字体加载\nvar font = new FontFaceObserver(fontName);\nfont.load(null, 150000).then(() =&gt; {\n    const activeObject = this.canvas.c.getActiveObjects()[0]\n    activeObject &amp;&amp; activeObject.set(&#x27;fontFamily&#x27;, fontName);\n    this.canvas.c.renderAll()\n    this.$Spin.hide();\n}).catch((err) =&gt; {\n    this.$Spin.hide();\n})\n</code></pre><h3>元素对齐</h3>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9dd4ffa48d104810b895c82c705701d2~tplv-k3u1fbpfcp-watermark.image?\" alt=\"对齐.gif\">\n元素对齐区分单选元素与多选元素，单选元素时只支持相对于画布水平、垂直、水平垂直对齐。</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; name为 centerH | centerV | center\nposition(name){\n  const activeObject = this.canvas.c.getActiveObject()\n  if(activeObject){\n    activeObject[name]()\n    this.canvas.c.renderAll()\n  }\n}\n</code></pre><p>多元素对齐有上下左右对齐、水平、垂直对齐，主要是通过获得最边缘元素的坐标，然后进行计算排序，如顶部对齐代码：</p>\n<pre class=\"prettyprint\"><code>const activeObject = this.canvas.c.getActiveObject();\n  if (activeObject &amp;&amp; activeObject.type === &#x27;activeSelection&#x27;) {\n        const activeSelection = activeObject;\n        console.log(activeSelection)\n        const activeObjectTop = -(activeObject.height &#x2F; 2);\n        activeSelection.forEachObject(item =&gt; {\n          item.set({\n                top: activeObjectTop,\n            });\n            item.setCoords();\n            this.canvas.c.renderAll();\n        });\n    }\n}\n</code></pre><p>平均分配会复杂一些，需要计算出边缘与元素间距，再进行设置，<a href=\"https://github.com/nihaojob/vue-fabric-editor/blob/main/src/components/align.vue\">详见代码</a>。</p>\n<h3>其他用法</h3>\n<p>编辑器经常需要给元素进行分组/拆分组合、调整层级、回退、快捷键、画布放大/缩小、导入/导出文件等功能，不再一一罗列，这个小编辑器都已经支持，大家感兴趣的可以看源码。</p>\n<ul>\n<li><a href=\"https://github.com/nihaojob/vue-fabric-editor/blob/main/src/components/group.vue\">组合</a></li>\n<li><a href=\"https://github.com/nihaojob/vue-fabric-editor/blob/main/src/components/layer.vue\">层级调整</a></li>\n<li><a href=\"https://github.com/nihaojob/vue-fabric-editor/blob/main/src/plugin/hotkeys.js\">快捷键实现</a></li>\n<li><a href=\"https://github.com/nihaojob/vue-fabric-editor/blob/main/src/components/zoom.vue\">画布放大缩小</a></li>\n<li><a href=\"https://github.com/nihaojob/vue-fabric-editor/blob/main/src/components/save.vue\">导入/导出</a></li>\n</ul>\n<h3>总结</h3>\n<p>fabric.js的功能很强大，可以很轻松的开发出一个简版的图片编辑器，自定义素材、模板、字体文件；还可以结合数据接口拼接模板生成图片，很轻松的实现定制模板 + 生成图片的功能，比如我的朋友借助我的功能 + 成语接口生成成语图片，在小红书上斩获了八千多的粉丝。</p>\n<p>最后希望大家能够通过这个项目学习到fabric.js的基础用法，感兴趣的话可以一起维护这款小编辑器，欢迎star。</p>\n<p><a href=\"https://github.com/nihaojob/vue-fabric-editor\">https://github.com/nihaojob/vue-fabric-editor</a></p>\n</div>",
    "title": "使用fabric.js 快速开发一个图片编辑器",
    "last_reply_at": "2023-04-15T08:12:03.573Z",
    "good": false,
    "top": false,
    "reply_count": 6,
    "visit_count": 5989,
    "create_at": "2022-10-17T03:05:02.316Z",
    "author": {
      "loginname": "nihaojob",
      "avatar_url": "https://avatars.githubusercontent.com/u/13534626?v=4&s=120"
    }
  },
  {
    "id": "63ecac6a0072081eb39e2b11",
    "author_id": "54009f5ccd66f2eb37190485",
    "tab": "share",
    "content": "<div class=\"markdown-text\"><p><a href=\"https://talk.aliyun.com/live?id=11741877.9369914\">https://talk.aliyun.com/live?id=11741877.9369914</a></p>\n<p>以上内容仅代表嘉宾个人观点，于2023年2月14日发布于阿里云大咖说，存在一定时效性，仅供学习和参考。</p>\n</div>",
    "title": "《狼书(卷3)：Node.js高级技术》视频版本",
    "last_reply_at": "2023-04-14T07:06:25.796Z",
    "good": false,
    "top": false,
    "reply_count": 1,
    "visit_count": 4306,
    "create_at": "2023-02-15T09:56:58.752Z",
    "author": {
      "loginname": "i5ting",
      "avatar_url": "https://avatars.githubusercontent.com/u/3118295?v=4&s=120"
    }
  },
  {
    "id": "6438587c6779ea228414dbca",
    "author_id": "564c2f011ba2ef107f854d91",
    "tab": "share",
    "content": "<div class=\"markdown-text\"><p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/22d9d33079b840e3aa3d7d0b603139eb~tplv-k3u1fbpfcp-zoom-crop-mark:1512:1512:1512:851.awebp?\" alt></p>\n<p>被裁了，最近在摸鱼写文档，这两天研究了下浏览器环境下摆脱 ffmpeg.wasm 实现 GIF 转视频的功能，现在浏览器提供的 API 越来越靠近底层，浏览器在发展个几年可能真没 Electron 啥事了 [狗头] 。</p>\n<p>不重复发文了，发掘金了：<a href=\"https://juejin.cn/post/7221557738537549879\">聊聊 WebCodecs 实现 GIF 视频转码</a></p>\n<p>欢迎大佬们指教~</p>\n</div>",
    "title": "聊聊 WebCodecs 实现 GIF 视频转码",
    "last_reply_at": "2023-04-13T19:31:08.736Z",
    "good": false,
    "top": false,
    "reply_count": 0,
    "visit_count": 1019,
    "create_at": "2023-04-13T19:31:08.736Z",
    "author": {
      "loginname": "kinglisky",
      "avatar_url": "https://avatars.githubusercontent.com/u/15852576?v=4&s=120"
    }
  },
  {
    "id": "643668336779ea6c4214da68",
    "author_id": "5896f254f46268be08aea4dd",
    "tab": "share",
    "content": "<div class=\"markdown-text\"><p>小程序使用uniapp开发，后端使用java。因为实后端java开发，前端不擅长，有一些地方写的不是很合理。不过主要目的还是分享免费的编程课程。正在找编程资源的可以看看，可能你要的就能搜到，每天都会更新一些资源。\n<img src=\"//static.cnodejs.org/FmBeKhXk1La4M-1xzwnIiLRZq_Ip\" alt=\"素材1.png\">\n<img src=\"//static.cnodejs.org/FgF93KX8qwHSlleM5X6Gmug5RFo2\" alt=\"素材2.png\">\n<img src=\"//static.cnodejs.org/Fo3cR9S0MO2OPOBe9X1Mhb7M7GXg\" alt=\"素材3.png\">\n<img src=\"//static.cnodejs.org/FnMtv4MbZU0NRrn1Q8Ql1gRYJDCc\" alt=\"素材4.png\">\n<img src=\"//static.cnodejs.org/Fl4_GBEs_KDU3A8PzuqpHtym9FFg\" alt=\"二维码.jpg\"></p>\n</div>",
    "title": "自己开发了编程课程搜索的小程序，基本慕课网的课程都能搜到",
    "last_reply_at": "2023-04-12T08:13:39.595Z",
    "good": false,
    "top": false,
    "reply_count": 0,
    "visit_count": 1331,
    "create_at": "2023-04-12T08:13:39.595Z",
    "author": {
      "loginname": "mikfake",
      "avatar_url": "https://avatars.githubusercontent.com/u/24414429?v=4&s=120"
    }
  },
  {
    "id": "64324a106779ea74ff14d820",
    "author_id": "556a6cb7f6ec9c0f020376c3",
    "tab": "ask",
    "content": "<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/FmtF2x_7JtxGcSAewTxaKIg7ysLc\" alt=\"image.png\"></p>\n<p>在nestjs项目中运行e2e test报错，服务是正常的，是循环依赖的问题吗？</p>\n<p>jest-e2e.json</p>\n<pre class=\"prettyprint language-json\"><code>{\n  &quot;moduleFileExtensions&quot;: [&quot;js&quot;, &quot;json&quot;, &quot;ts&quot;],\n  &quot;rootDir&quot;: &quot;.&quot;,\n  &quot;modulePaths&quot;: [&quot;&lt;rootDir&gt;&#x2F;..&#x2F;&quot;],\n  &quot;testEnvironment&quot;: &quot;node&quot;,\n  &quot;testRegex&quot;: &quot;.e2e-spec.ts$&quot;,\n  &quot;transform&quot;: {\n    &quot;^.+\\\\.(t|j)s$&quot;: &quot;ts-jest&quot;\n  },\n  &quot;moduleNameMapper&quot;: {\n    &quot;^@&#x2F;(.*)$&quot;: &quot;&lt;rootDir&gt;&#x2F;..&#x2F;src&#x2F;$1&quot;\n  }\n}\n</code></pre></div>",
    "title": "NestJS e2e test报错：Class extends value undefined is not a constructor or null",
    "last_reply_at": "2023-04-09T05:39:12.580Z",
    "good": false,
    "top": false,
    "reply_count": 1,
    "visit_count": 1292,
    "create_at": "2023-04-09T05:16:00.524Z",
    "author": {
      "loginname": "tashuo",
      "avatar_url": "https://avatars.githubusercontent.com/u/4208782?v=4&s=120"
    }
  },
  {
    "id": "642f27fa6779ea7c0e14d661",
    "author_id": "53aecc6fa087f4562011cc62",
    "tab": "ask",
    "content": "<div class=\"markdown-text\"><p>。。。</p>\n</div>",
    "title": "react每个大版本都改变了啥？",
    "last_reply_at": "2023-04-08T00:40:14.211Z",
    "good": false,
    "top": false,
    "reply_count": 1,
    "visit_count": 1432,
    "create_at": "2023-04-06T20:13:46.192Z",
    "author": {
      "loginname": "zzz6519003",
      "avatar_url": "https://avatars.githubusercontent.com/u/1625608?v=4&s=120"
    }
  },
  {
    "id": "642e8f866779eaeae914d603",
    "author_id": "5f1e462bf0739b0e62d1234c",
    "tab": "ask",
    "content": "<div class=\"markdown-text\"><p>看官网文档里提到关于多进程的情况下，必须为每一个进程都创建sequelize实例：</p>\n<blockquote>\n<p>If you’re connecting to the database from multiple processes, you’ll have to create one instance per process, but each instance should have a maximum connection pool size of such that the total maximum size is respected.</p>\n</blockquote>\n<p>生产环境下，肯定是多负载多进程的情况，并且一般用cluster模块去进行进程处理</p>\n<pre class=\"prettyprint language-js\"><code>if (cluster.isMaster) {\n    for (var i = 0; i &lt; env.CPU; i++) {\n        cluster.fork();\n    }\n\n    cluster.on(&#x27;fork&#x27;, worker =&gt; {\n        log(&#96;worker ${worker.process.pid} forked success&#96;, &#x27;info&#x27;, logOptions);\n    });\n\n    cluster.on(&#x27;online&#x27;, worker =&gt; {\n        log(&#96;worker ${worker.process.pid} responded after it was forked&#96;, &#x27;info&#x27;, logOptions);\n    });\n\n    cluster.on(&#x27;exit&#x27;, function (worker, code, signal) {\n        log(&#96;worker ${worker.process.pid} died (${signal || code})&#96;, &#x27;warn&#x27;, logOptions);\n        cluster.fork();\n    });\n} else {\n    require(&#x27;..&#x2F;app.js&#x27;);\n}\n</code></pre><p>想请教下这种情况下，Sequelize的实例初始化应该在什么阶段？</p>\n</div>",
    "title": "NodeJS+Sequelize在生产环境下，最合适的建立连接池的方式是？",
    "last_reply_at": "2023-04-06T09:23:18.009Z",
    "good": false,
    "top": false,
    "reply_count": 0,
    "visit_count": 1326,
    "create_at": "2023-04-06T09:23:18.009Z",
    "author": {
      "loginname": "monkeytwins",
      "avatar_url": "https://avatars.githubusercontent.com/u/1046295?v=4&s=120"
    }
  },
  {
    "id": "642b87e96779ea520714d3ff",
    "author_id": "5db928ac865a9844a301eb86",
    "tab": "ask",
    "content": "<div class=\"markdown-text\"><p>在nodejs 里面执行\nconst result = await redis.sismember(<code>puzzle_user</code>,  key);\nredis里面没有集合puzzle_user，result 返回的结果为啥是true</p>\n</div>",
    "title": "await 不能回调 sismember 吗",
    "last_reply_at": "2023-04-04T02:14:01.826Z",
    "good": false,
    "top": false,
    "reply_count": 0,
    "visit_count": 1135,
    "create_at": "2023-04-04T02:14:01.826Z",
    "author": {
      "loginname": "yuexiangqianlong",
      "avatar_url": "https://avatars.githubusercontent.com/u/26164678?v=4&s=120"
    }
  },
  {
    "id": "64214ce30072087f7c9e50a9",
    "author_id": "59e6c301bcfcc03162f2ffc3",
    "tab": "share",
    "content": "<div class=\"markdown-text\"><p>发现了个奇怪的现象， 很多人都用的取整方式\n~~(2418473332.1)， 0|(2418473332.1) 竟然是负数 -1876493964；</p>\n</div>",
    "title": "node.js 向下取整",
    "last_reply_at": "2023-03-27T08:51:01.993Z",
    "good": false,
    "top": false,
    "reply_count": 1,
    "visit_count": 1484,
    "create_at": "2023-03-27T07:59:31.630Z",
    "author": {
      "loginname": "spitWind",
      "avatar_url": "https://avatars.githubusercontent.com/u/18753430?v=4&s=120"
    }
  },
  {
    "id": "641d10cf007208d9009e4ca5",
    "author_id": "584139e9539c22b15689981c",
    "tab": "ask",
    "content": "<div class=\"markdown-text\"><p>使用场景描述：</p>\n<p>我们公司内部的一个系统，员工每次创建一个记录，可以给这个记录加标签。其中，有5个标签是固定的，提前设置好的，员工可以改掉它们，还可以添加自定义的标签。这个标签只有他自己能看到。我觉得这个功能需求跟Github的issue中提供的标签系统很像，但是不知道怎么设计数据库结构。</p>\n<p>请问，这个场景下，使用MySQL数据库该怎么设计表结构啊？如果有必要，我们可以使用Redis。</p>\n<p>请各位大神帮帮忙。</p>\n</div>",
    "title": "请大神帮帮忙，看看怎么设计这样的数据库？类似Github的标签功能。",
    "last_reply_at": "2023-03-27T05:41:45.091Z",
    "good": false,
    "top": false,
    "reply_count": 4,
    "visit_count": 2082,
    "create_at": "2023-03-24T02:54:07.100Z",
    "author": {
      "loginname": "hz0324",
      "avatar_url": "https://avatars.githubusercontent.com/u/5040078?v=4&s=120"
    }
  },
  {
    "id": "641e679c00720825c09e4d97",
    "author_id": "5874ce202d086de6340db320",
    "tab": "share",
    "content": "<div class=\"markdown-text\"><h1>基于 React 拖动配置流程图</h1>\n<p>flow-chart 基于 React+konva+TypeScript 流程图开发，支持新增/编辑卡片，支持动态配置卡片参数表单（即动态配置表单功能），支持 GET、POST 接口在线调试，支持拖动配置流程图，支持拷贝、删除、撤销、恢复、全选、对齐卡片等等。</p>\n<p>项目纯前端-Demo 地址：<a href=\"https://myfirebug.github.io/flow-chart/index.html#/login\">https://myfirebug.github.io/flow-chart/index.html#/login</a></p>\n<p>用户名：admin, 密码：123456</p>\n<p><strong>新增/编辑卡片图片</strong></p>\n<p><img src=\"https://myfirebug.github.io/example-images/flow-chart/01.png\" alt=\"RUNOOB 图标\">\n<img src=\"https://myfirebug.github.io/example-images/flow-chart/02.png\" alt=\"RUNOOB 图标\">\n<img src=\"https://myfirebug.github.io/example-images/flow-chart/03.png\" alt=\"RUNOOB 图标\"></p>\n<p><strong>新增/编辑流程图图片</strong>\n<img src=\"https://myfirebug.github.io/example-images/flow-chart/04.png\" alt=\"RUNOOB 图标\"></p>\n<p><strong>主要依赖：</strong></p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>版本</th>\n<th>名称</th>\n<th>版本</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>react</td>\n<td>18.0.0</td>\n<td>react-dom</td>\n<td>18.0.0</td>\n</tr>\n<tr>\n<td>typescript</td>\n<td>4.6.3</td>\n<td>jsoneditor</td>\n<td>9.9.0</td>\n</tr>\n<tr>\n<td>redux</td>\n<td>4.1.2</td>\n<td>react-redux</td>\n<td>7.2.8</td>\n</tr>\n<tr>\n<td>konva</td>\n<td>8.4.2</td>\n<td>redux-logger</td>\n<td>3.0.6</td>\n</tr>\n<tr>\n<td>redux-persist</td>\n<td>6.0.0</td>\n<td>redux-thunk</td>\n<td>2.4.1</td>\n</tr>\n<tr>\n<td>react-app-rewire</td>\n<td>2.2.1</td>\n<td>echarts</td>\n<td>5.3.2</td>\n</tr>\n<tr>\n<td>antd</td>\n<td>4.19.3</td>\n<td>axios</td>\n<td>0.26.1</td>\n</tr>\n<tr>\n<td>cross-env</td>\n<td>7.0.3</td>\n<td>customize-cra</td>\n<td>1.0.0</td>\n</tr>\n<tr>\n<td>react-konva</td>\n<td>18.2.4</td>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p><strong>开发环境</strong></p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>版本</th>\n<th>名称</th>\n<th>版本</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>node</td>\n<td>16.17.0</td>\n<td>npm</td>\n<td>8.15.0</td>\n</tr>\n</tbody>\n</table>\n<p><strong>已完成功能</strong></p>\n<table>\n<thead>\n<tr>\n<th>页面</th>\n<th>是否完成（功能）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>登录</td>\n<td>是</td>\n</tr>\n<tr>\n<td>首页</td>\n<td>是</td>\n</tr>\n<tr>\n<td>流程</td>\n<td>是</td>\n</tr>\n<tr>\n<td>卡片列表</td>\n<td>是</td>\n</tr>\n<tr>\n<td>卡片新增/编辑</td>\n<td>入参配置（input,textArea, number, pasword, select, checkboxGroup,radioGroup,cascader,switch，date,dateRange,time,timeRange,treeSelect 配置功能开发）置顶、置顶、上移、下移、复制、删除功能开发(正在开发中···)</td>\n</tr>\n<tr>\n<td>流程图列表</td>\n<td>是</td>\n</tr>\n<tr>\n<td>流程图新增/编辑</td>\n<td>支持拷贝、删除、撤销、恢复、全选、对齐卡片、ctrl+单机多选、卡片表参数配置（卡片新增/编辑里的拼入参配置表单使用）</td>\n</tr>\n</tbody>\n</table>\n<p><strong>已完成的组件</strong></p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>名称</th>\n<th>名称</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Input</td>\n<td>TextArea</td>\n<td>InputNumber</td>\n</tr>\n</tbody>\n</table>\n<h1>框架使用技术</h1>\n<ul>\n<li>框架为<code>create-react-app</code>构架，搭配<code>react-router-dom</code>、<code>redux</code>、<code>react-redux</code>、<code>redux-thunk</code>、<code>redux-persist</code>、<code>redux-logger</code>、<code>axios</code>，UI 框架为<code>antd@4.19.3</code></li>\n</ul>\n<h1>学习文档</h1>\n<ul>\n<li><a href=\"https://react.docschina.org\" title=\"react中文官网\">react 中文官网</a></li>\n<li><a href=\"https://reactjs.org\" title=\"react英文官网\">react 英文官网</a></li>\n<li><a href=\"http://cn.redux.js.org\" title=\"redux中文官网\">redux 中文官网</a></li>\n<li><a href=\"https://redux.js.org\" title=\"redux英文官网\">redux 英文官网</a></li>\n<li><a href=\"https://www.html.cn/create-react-app/docs/getting-started/\" title=\"create-react-app中文文档\">create-react-app 中文文档</a></li>\n<li><a href=\"https://3x.ant.design/index-cn\" title=\"antd官网\">antd 官网</a></li>\n<li><a href=\"https://github.com/timarney/react-app-rewired#readme\" title=\"在不npm run inject的情况下修改webpack\">react-app-rewired</a></li>\n<li><a href=\"https://github.com/webpack-contrib/webpack-bundle-analyzer\" title=\"webpack-bundle-analyzer分析SPA应用\">webpack-bundle-analyzer 分析 SPA 应用</a></li>\n</ul>\n<h1>依赖安装、启动、打包</h1>\n<pre class=\"prettyprint\"><code>## 克隆\n\n## 启动开发环境（开发调试时使用）\n### &#96;npm start&#96;\n\n## 构建测试项目\n## &#96;npm build:test&#96;\n\n## 构建正式项目\n### &#96;npm build:production&#96;\n\n</code></pre><h1>目录结构</h1>\n<pre class=\"prettyprint\"><code>flow-chart\n├── src\n│   ├── assets                       &#x2F;&#x2F; 静态资源\n│   ├── components                   &#x2F;&#x2F; 公共组件\n│   ├── config                       &#x2F;&#x2F; 配置文件\n│   ├── mock                         &#x2F;&#x2F; 模拟接口\n│   ├── pages                        &#x2F;&#x2F; 页面\n│   │   ├── card-configuration       &#x2F;&#x2F; 卡片配置页面\n│   │   ├── diagrams-configuration   &#x2F;&#x2F; 流程图配置页面\n│   │   ├── frame                    &#x2F;&#x2F; 框架页面\n│   │   ├── home                     &#x2F;&#x2F; 首页页面\n│   │   ├── login                    &#x2F;&#x2F; 登录页面\n│   │   └── process                  &#x2F;&#x2F; 流程图\n│   │   │   └── card                 &#x2F;&#x2F; 卡片列表\n│   │   │   └── diagrams             &#x2F;&#x2F; 流程列表\n│   ├── service                      &#x2F;&#x2F; 接口服务\n│   ├── store                        &#x2F;&#x2F; 状态\n│   ├── types                        &#x2F;&#x2F; ts基本类型\n│   ├── utils                        &#x2F;&#x2F; 工具\n│   └── form                         &#x2F;&#x2F; 组件及其配置\n</code></pre><p><strong><a href=\"https://github.com/myfirebug/flow-chart\">欢迎star</a></strong></p>\n</div>",
    "title": "基于 React+Konva+TypeScript 拖动配置流程图，配置卡片参数表单欢迎在线体验",
    "last_reply_at": "2023-03-25T03:16:44.938Z",
    "good": false,
    "top": false,
    "reply_count": 0,
    "visit_count": 1695,
    "create_at": "2023-03-25T03:16:44.938Z",
    "author": {
      "loginname": "myfirebug",
      "avatar_url": "https://avatars.githubusercontent.com/u/8624981?v=4&s=120"
    }
  },
  {
    "id": "639b11c8f0ccae8effe0fa0b",
    "author_id": "5dd34ece7651572e0955de6a",
    "tab": "ask",
    "content": "<div class=\"markdown-text\"><p>PS E:\\study\\forVideo&gt; npm run start</p>\n<blockquote>\n<p>microblog@0.0.0 start\nnode ./bin/www</p>\n</blockquote>\n<p>E:\\study\\forVideo\\service\\service.js:1\nimport got from “got”;\n^^^^^^</p>\n<p>SyntaxError: Cannot use import statement outside a module</p>\n<p>请问这是为什么？\n项目框架是 “express”: “~4.16.1”,\n“got”: “^12.5.3”,</p>\n</div>",
    "title": "node V16.16.0 无法使用import语句",
    "last_reply_at": "2023-03-22T07:50:59.815Z",
    "good": false,
    "top": false,
    "reply_count": 3,
    "visit_count": 3676,
    "create_at": "2022-12-15T12:23:36.022Z",
    "author": {
      "loginname": "scottMan1001",
      "avatar_url": "https://avatars.githubusercontent.com/u/38151889?v=4&s=120"
    }
  },
  {
    "id": "641910d90072080bc59e4a65",
    "author_id": "5b4fdf5faef62f1b0f9e0434",
    "tab": "ask",
    "content": "<div class=\"markdown-text\"><p><a href=\"https://github.com/nodejs/tooling/issues/175\">https://github.com/nodejs/tooling/issues/175</a></p>\n</div>",
    "title": "请问如何排查Nodejs进程退出原因，只有pid和dmseg信息，dmseg里面也没找到有用的信息",
    "last_reply_at": "2023-03-21T02:23:42.369Z",
    "good": false,
    "top": false,
    "reply_count": 1,
    "visit_count": 1448,
    "create_at": "2023-03-21T02:05:13.903Z",
    "author": {
      "loginname": "assmdx",
      "avatar_url": "https://avatars.githubusercontent.com/u/19722693?v=4&s=120"
    }
  },
  {
    "id": "5d463798bf26dc7fc53373e8",
    "author_id": "5c98ed8300bcfd7eb2be614f",
    "tab": "ask",
    "content": "<div class=\"markdown-text\"><p>最近在看狼书里面提到捕获 uncaughtException 异常防止 process 退出。\n看了一下 Node 文档， 提到</p>\n<blockquote>\n<p>需要注意，如果打算使用 ‘uncaughtException’ 事件作为异常处理的最后补救机制，这是非常粗糙的设计方式</p>\n</blockquote>\n<p>感觉对 uncaughtException 使用场景很迷茫，麻烦指点一下。</p>\n</div>",
    "title": "如何正确使用 uncaughtException ？",
    "last_reply_at": "2023-03-20T08:07:41.517Z",
    "good": false,
    "top": false,
    "reply_count": 4,
    "visit_count": 4006,
    "create_at": "2019-08-04T01:40:40.599Z",
    "author": {
      "loginname": "NiLinli",
      "avatar_url": "https://avatars2.githubusercontent.com/u/25059127?v=4&s=120"
    }
  },
  {
    "id": "64045929007208665e9e3d5b",
    "author_id": "58cdfd7528be82df16560950",
    "tab": "share",
    "content": "<div class=\"markdown-text\"><p><a href=\"https://github.com/hsiaosiyuan0/slowjs\">SlowJS</a> - QuickJS 降速版本！</p>\n<ul>\n<li>将 5.4W 行 <a href=\"https://github.com/bellard/quickjs\">quickjs.c</a> 进行拆分</li>\n<li>增加断点调试功能</li>\n<li>增加内存 dump WIP</li>\n</ul>\n<p>一起学习 QuickJS!</p>\n</div>",
    "title": "SlowJS!",
    "last_reply_at": "2023-03-18T04:56:57.016Z",
    "good": false,
    "top": false,
    "reply_count": 3,
    "visit_count": 2097,
    "create_at": "2023-03-05T08:56:09.993Z",
    "author": {
      "loginname": "hsiaosiyuan0",
      "avatar_url": "https://avatars.githubusercontent.com/u/22588905?v=4&s=120"
    }
  },
  {
    "id": "641422a000720876469e47b3",
    "author_id": "5e81836f58ab6717beb7d52e",
    "tab": "share",
    "content": "<div class=\"markdown-text\"><p><img src=\"https://show.cool-admin.com/AI%E7%BC%96%E7%A0%81.gif\" alt=\"AI编码.gif\"></p>\n<p>cool-admin基于nodejs的后台管理系统开发框架</p>\n<p><strong>官网</strong>\n<a href=\"https://cool-js.com/\">https://cool-js.com/</a></p>\n<p><strong>演示地址</strong>\n<a href=\"https://show.cool-admin.com\">https://show.cool-admin.com</a>\n账户：admin\n密码：123456</p>\n</div>",
    "title": "【🔥AI编码】cool-admin6.0预览版",
    "last_reply_at": "2023-03-17T08:19:44.747Z",
    "good": false,
    "top": false,
    "reply_count": 0,
    "visit_count": 1555,
    "create_at": "2023-03-17T08:19:44.747Z",
    "author": {
      "loginname": "cool-team-official",
      "avatar_url": "https://avatars.githubusercontent.com/u/62868950?v=4&s=120"
    }
  },
  {
    "id": "6413ff530072087f049e4790",
    "author_id": "5e81836f58ab6717beb7d52e",
    "tab": "share",
    "content": "<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/FlSBO6MuaiLeKq5QuxAwxqkpxpya\" alt=\"微信图片_20230317134522.jpg\">\n<img src=\"//static.cnodejs.org/FsJUy2c0VGU3hlaY3J4NNnvdqs_7\" alt=\"微信图片_20230317134517.jpg\">\n<img src=\"//static.cnodejs.org/FpniM8qx15wLB3t_ra-vzZGLOPqo\" alt=\"微信图片_20230317134527.jpg\">\n<img src=\"//static.cnodejs.org/FpFnYRtpNYMuvf21GPZg-gV68Gl8\" alt=\"微信图片_20230317134535.jpg\"></p>\n<p>用法群里\n<a href=\"/user/cool-ai\">@cool-ai</a> + 你的问题  （ChatGPT聊天）\n<a href=\"/user/cool-ai\">@cool-ai</a> img + 你想生成的图片  （AI绘画）</p>\n<p><img src=\"//static.cnodejs.org/FplcOosVU82faVewXT6DQO6VKZEo\" alt=\"微信图片_20230317134542.jpg\"></p>\n</div>",
    "title": "绝对免费的AI绘画和ChatGpt",
    "last_reply_at": "2023-03-17T05:49:07.653Z",
    "good": false,
    "top": false,
    "reply_count": 0,
    "visit_count": 1907,
    "create_at": "2023-03-17T05:49:07.653Z",
    "author": {
      "loginname": "cool-team-official",
      "avatar_url": "https://avatars.githubusercontent.com/u/62868950?v=4&s=120"
    }
  },
  {
    "id": "6205ed8da08b390c3c09c7d8",
    "author_id": "5c81f15090c14711cc8cb87e",
    "tab": "ask",
    "content": "<div class=\"markdown-text\"><p>NestJs目前周下载量已经达到120万了，用nestjs开发的人多吗？</p>\n<p><img src=\"//static.cnodejs.org/FglzZfP40wt2qMNLHx0aLSswMOwc\" alt=\"nestjs.jpg\"></p>\n</div>",
    "title": "NestJs目前周下载量已经达到120万了 用nestjs开发的人多吗",
    "last_reply_at": "2023-03-13T06:15:05.622Z",
    "good": false,
    "top": false,
    "reply_count": 32,
    "visit_count": 98418,
    "create_at": "2022-02-11T05:01:01.085Z",
    "author": {
      "loginname": "phonegap100",
      "avatar_url": "https://avatars.githubusercontent.com/u/5773766?v=4&s=120"
    }
  },
  {
    "id": "6409c2d80072081dd99e415b",
    "author_id": "59aa34b3ea0aea6b0c64e731",
    "tab": "share",
    "content": "<div class=\"markdown-text\"><h1>TerminalBot</h1>\n<p>chatGPT 简直是我们程序员的福音，可以说是一对一导师了，但是每次遇到问题还需要打开网页去提问，而且还一个字一个字的慢慢蹦，还要回复我英文，我看又看不懂，作为一个程序员怎么能忍受得了呢？</p>\n<p>于是我就突发奇想，能不能直接在终端里面问问题，并且直接回复我中文，还有我想要翻译的时候，直接给我翻译，想要给变量名起名的时候，直接回复我变量名，不需要我过多的解释。</p>\n<p>【🍭TerminalBot】它来了，先看看效果。</p>\n<p><img src=\"//static.cnodejs.org/Fgbtyr_dMPKoRKlzAMzRihkL-LBM\" alt=\"demo_zh.png\">\n<img src=\"//static.cnodejs.org/FvCCNhA6Vw48pxBVyQ_T8oEmi_iN\" alt=\"demo2_zh.png\">\n我自定义了2个命令，分别是<code>bot</code>和<code>bot2</code> bot我给它添加了使用中文回复我的“prompt”，bot2我添加了给我翻译的“prompt”</p>\n<p>看看bot命令的json配置</p>\n<h2>bot</h2>\n<pre class=\"prettyprint language-json\"><code>{\n  &quot;authToken&quot;: &quot;your authToken&quot;,\n  &quot;proxyURL&quot;: &quot;http:&#x2F;&#x2F;127.0.0.1:7890&quot;,\n  &quot;questionPrefix&quot;: &quot;&quot;,\n  &quot;prompt&quot;:[\n    {\n      &quot;role&quot;: &quot;system&quot;,\n      &quot;content&quot;: &quot;你是xusenlin开发的一个终端chatGPT，你的名字叫TerminalBot，你的所有回答将使用中文回复。&quot;\n    },\n    {\n      &quot;role&quot;: &quot;system&quot;,\n      &quot;content&quot;: &quot;TerminalBot的安装非常简单，只需要到https:&#x2F;&#x2F;github.com&#x2F;xusenlin&#x2F;terminal-bot下载一个名为bot的二进制文件，然后放到你的环境变量里面，在用户目录下填写bot.json配置，提问的时候输入&#96;&#96;&#96;bot -q 你的问题&#96;&#96;&#96;就能快速得到回答,这样你就可以拥有一个终端机器人助手了，非常酷。如果你想拥有更多的终端机器人助手,只需要复制一份二进制文件重命名为bot2，然后填写相应的bot2.json配置文件就行。&quot;\n    }\n  ]\n}\n</code></pre><h2>bot2</h2>\n<pre class=\"prettyprint language-json\"><code>{\n  &quot;authToken&quot;: &quot;xxx&quot;,\n  &quot;proxyURL&quot;: &quot;http:&#x2F;&#x2F;127.0.0.1:7890&quot;,\n  &quot;questionPrefix&quot;: &quot;翻译:&quot;,\n  &quot;prompt&quot;: [\n    {\n      &quot;role&quot;: &quot;system&quot;,\n      &quot;content&quot;: &quot;你是一个翻译助手，你不要回答用户的任何问题，如果用户向你发送中文，你直接回复翻译好的英文，如果用户向你发送英文，你直接回复翻译好的中文。&quot;\n    }\n  ]\n}\n</code></pre><p>哈哈，不知道你有好的prompt推荐不，这样我们就能配置各式各样的小助手了，工作效率嘎嘎快。</p>\n<p>开源了，<a href=\"https://github.com/xusenlin/terminal-bot\">https://github.com/xusenlin/terminal-bot</a>\n喜欢不要吝啬给个星星哇。</p>\n</div>",
    "title": "[🍭TerminalBot]我把chatGPT放到了终端里面，自定义多个小助手并快速提问",
    "last_reply_at": "2023-03-09T11:28:24.605Z",
    "good": false,
    "top": false,
    "reply_count": 0,
    "visit_count": 1464,
    "create_at": "2023-03-09T11:28:24.605Z",
    "author": {
      "loginname": "xusenlin",
      "avatar_url": "https://avatars.githubusercontent.com/u/14531906?v=4&s=120"
    }
  },
  {
    "id": "64088323007208a3369e406c",
    "author_id": "59eeb8e11bbf067d5c3fa7c6",
    "tab": "share",
    "content": "<div class=\"markdown-text\"><h2>介绍</h2>\n<p>CabloyJS提供了一个内置模块<code>a-wasmgo</code>，将go wasm模块的异步加载运行机制进行了封装，使我们可以非常方便的在CabloyJS项目中引入go wasm，从而支持更多的业务场景开发</p>\n<p>下面，我们以测试模块<code>test-party</code>为例，演示引入go wasm模块并运行需要哪几个步骤</p>\n<h2>效果演示</h2>\n<ul>\n<li>请直接打开此演示页面：<a href=\"https://test.cabloy.com/#!/test/party/wasm_go\">https://test.cabloy.com/#!/test/party/wasm_go</a></li>\n</ul>\n<h2>1. 准备工作</h2>\n<ol>\n<li>\n<p>安装go环境：参见 <a href=\"https://go.dev/doc/install\">https://go.dev/doc/install</a></p>\n</li>\n<li>\n<p>创建CabloyJS项目：参见 <a href=\"https://cabloy.com/zh-cn/articles/guide-quick-start.html\">https://cabloy.com/zh-cn/articles/guide-quick-start.html</a></p>\n</li>\n<li>\n<p>安装test-party演示套件：参见 <a href=\"https://store.cabloy.com/zh-cn/articles/test-party.html\">https://store.cabloy.com/zh-cn/articles/test-party.html</a></p>\n</li>\n</ol>\n<h2>2. 开发一个go wasm模块</h2>\n<h3>2.1 go源码</h3>\n<p><code>src/suite-vendor/test-party/modules/test-party/front/src/assets/wasm/demo.go</code></p>\n<pre class=\"prettyprint language- go\"><code>package main\n\nimport (\n\t&quot;fmt&quot;\n\t&quot;syscall&#x2F;js&quot;\n)\n\nfunc main() {\n\tfmt.Println(&quot;Hello, World!&quot;)\n\talert := js.Global().Get(&quot;alert&quot;)\n\talert.Invoke(&quot;alert!&quot;)\n}\n</code></pre><ol>\n<li>\n<p>fmt.Println：在控制台输出一个字符串</p>\n</li>\n<li>\n<p>js.Global().Get(“alert”)：获取网页中的window.alert方法</p>\n</li>\n<li>\n<p>alert.Invoke：执行alert方法</p>\n</li>\n</ol>\n<h3>2.2 编译wasm</h3>\n<p>进入源码所在目录，将<code>demo.go</code>编译为<code>demo.wasm</code></p>\n<pre class=\"prettyprint language- bash\"><code>$ cd src&#x2F;suite-vendor&#x2F;test-party&#x2F;modules&#x2F;test-party&#x2F;front&#x2F;src&#x2F;assets&#x2F;wasm&#x2F;\n$ GOOS=js GOARCH=wasm go build -o demo.wasm demo.go\n</code></pre><ul>\n<li>更详细说明，请参见go官方文档：<a href=\"https://github.com/golang/go/wiki/WebAssembly\">https://github.com/golang/go/wiki/WebAssembly</a></li>\n</ul>\n<h2>3. 加载并运行wasm</h2>\n<p>测试模块<code>test-party</code>提供了一个演示页面，页面路径为：<a href=\"http://localhost:9092/#!/test/party/wasm_go\">http://localhost:9092/#!/test/party/wasm_go</a></p>\n<p>该页面提供了两个加载并运行wasm的方法：</p>\n<h3>3.1 两步执行</h3>\n<p><code>src/suite/test-party/modules/test-party/front/src/pages/wasm_go.jsx</code></p>\n<pre class=\"prettyprint language- javascript\"><code>import wasmDemo from &#x27;..&#x2F;assets&#x2F;wasm&#x2F;demo.wasm&#x27;;\n...\nasync onPerformRun1() {\n  &#x2F;&#x2F; go\n  let action = {\n    actionModule: &#x27;a-wasmgo&#x27;,\n    actionComponent: &#x27;sdk&#x27;,\n    name: &#x27;go&#x27;,\n  };\n  const go = await this.$meta.util.performAction({ ctx: this, action });\n  &#x2F;&#x2F; load wasm\n  action = {\n    actionModule: &#x27;a-wasmgo&#x27;,\n    actionComponent: &#x27;sdk&#x27;,\n    name: &#x27;loadWasm&#x27;,\n  };\n  const item = { source: wasmDemo };\n  const wasmResult = await this.$meta.util.performAction({ ctx: this, action, item });\n  &#x2F;&#x2F; run\n  await go.run(wasmResult.instance);\n},\n</code></pre><ol>\n<li>\n<p>内置模块<code>a-wasmgo</code>是异步模块，提供了一个<code>sdk</code>组件，用于封装异步加载并运行wasm的逻辑。因此需要通过调用<code>performAction</code>方法异步加载<code>a-wasmgo</code>模块，并调用其中的方法</p>\n</li>\n<li>\n<p>第一步，调用<code>performAction</code>取得<code>go</code>实例</p>\n</li>\n<li>\n<p>第二步，调用<code>performAction</code>异步加载<code>demo.wasm</code>模块</p>\n</li>\n<li>\n<p>调用<code>go.run</code>执行wasm模块的实例</p>\n</li>\n</ol>\n<h3>3.2 一步执行</h3>\n<p><code>src/suite/test-party/modules/test-party/front/src/pages/wasm_go.jsx</code></p>\n<pre class=\"prettyprint language- javascript\"><code>import wasmDemo from &#x27;..&#x2F;assets&#x2F;wasm&#x2F;demo.wasm&#x27;;\n...\nasync onPerformRun2() {\n  &#x2F;&#x2F; load&amp;run wasm\n  const action = {\n    actionModule: &#x27;a-wasmgo&#x27;,\n    actionComponent: &#x27;sdk&#x27;,\n    name: &#x27;run&#x27;,\n  };\n  const item = { source: wasmDemo };\n  await this.$meta.util.performAction({ ctx: this, action, item });\n},\n</code></pre><ol>\n<li>调用<code>performAction</code>时，直接传入<code>demo.wasm</code>模块，从而一次完成加载与运行的逻辑</li>\n</ol>\n<h2>附：performAction说明</h2>\n<ul>\n<li>action</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>actionModule</td>\n<td>模块名称，此处为<code>a-wasmgo</code></td>\n</tr>\n<tr>\n<td>actionComponent</td>\n<td>模块提供的组件，此处为<code>sdk</code></td>\n</tr>\n<tr>\n<td>name</td>\n<td>需要调用的方法名称，此处有以下可选值：<code>go/loadWasm/run</code></td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>item</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>source</td>\n<td>wasm模块的url地址，此处为<code>wasmDemo</code>，指向<code>'../assets/wasm/demo.wasm'</code></td>\n</tr>\n</tbody>\n</table>\n<h2><strong>相关链接</strong></h2>\n<ul>\n<li>\n<p>文档：<a href=\"https://cabloy.com/\">https://cabloy.com/</a></p>\n</li>\n<li>\n<p>演示：<a href=\"https://test.cabloy.com/\">https://test.cabloy.com/</a></p>\n</li>\n<li>\n<p>GitHub源码仓库: <a href=\"https://github.com/zhennann/cabloy\">https://github.com/zhennann/cabloy</a></p>\n</li>\n</ul>\n</div>",
    "title": "看看CabloyJS是如何异步加载并执行go wasm模块的",
    "last_reply_at": "2023-03-08T18:05:20.562Z",
    "good": false,
    "top": false,
    "reply_count": 1,
    "visit_count": 1430,
    "create_at": "2023-03-08T12:44:19.700Z",
    "author": {
      "loginname": "zhennann",
      "avatar_url": "https://avatars.githubusercontent.com/u/24246985?v=4&s=120"
    }
  },
  {
    "id": "63fc57a4007208fe309e331e",
    "author_id": "5d47c83b4f472f7fee152927",
    "tab": "ask",
    "content": "<div class=\"markdown-text\"><p>今天闲着没事看 coffeescript，发现 coffeescript 会把</p>\n<pre class=\"prettyprint language- coffeescript\"><code>a = undefined\nif a?\n  console.log a\n</code></pre><p>翻译成：</p>\n<pre class=\"prettyprint language- javascript\"><code>var a;\na = void 0;\nif (a != null) {\n  console.log(a);\n}\n</code></pre><p>然后我想了想、试了试，发现 <code>0</code>、<code>false</code>、<code>&quot;&quot;</code> 都不满足 <code>== null</code></p>\n<p>于是我就想，可不可以使用 <code>a == null</code> 来代替  <code>a === null</code> || <code>a === undefined</code> 呢？</p>\n</div>",
    "title": "可不可以用 a == null 来代替  a === null || a === undefined",
    "last_reply_at": "2023-03-08T13:34:27.271Z",
    "good": false,
    "top": false,
    "reply_count": 5,
    "visit_count": 3415,
    "create_at": "2023-02-27T07:11:32.059Z",
    "author": {
      "loginname": "daGaiGuanYu",
      "avatar_url": "https://avatars.githubusercontent.com/u/27003009?v=4&s=120"
    }
  },
  {
    "id": "63eded550072088b519e2bb9",
    "author_id": "5c9dda1599e62a362ff412ef",
    "tab": "share",
    "content": "<div class=\"markdown-text\"><p>之前写过一篇笔记，《<a href=\"https://juejin.cn/post/7155040639497797645\">使用fabric.js 快速开发一个图片编辑器</a>》，简单介绍了如何用vue和fabric.js快速开发一款编辑器。</p>\n<p>当时的版本比较粗糙，只能说是一个基础版的Demo，很多细节不够完善，参考了稿定设计和创客贴的设计编辑器，<strong>优化了很多必要的细节，也算是fabric.js的进阶用法</strong>，整理成笔记分享出来。</p>\n<p>项目地址：<a href=\"https://github.com/nihaojob/vue-fabric-editor\">https://github.com/nihaojob/vue-fabric-editor</a></p>\n<p>预览地址：<a href=\"https://nihaojob.github.io/vue-fabric-editor/\">https://nihaojob.github.io/vue-fabric-editor/</a></p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fb39b4abf3e940f8a9dc78032f4e7d0e~tplv-k3u1fbpfcp-zoom-1.image\" alt></p>\n<h2>正文</h2>\n<h3>1、架构演进</h3>\n<p>最早的设计是将 fabric.js创建的canvas对象通过provide传递给子组件使用，功能代码封装到vue组件中。前<strong>期基础功能尚能满足，但后期迭代时发现无法复用功能代码</strong>，如复制功能原来以按钮的形式存在，代码全部在复制组件中，在后期迭代中要在快捷键和右键菜单中增加复制功能，没办法复用；</p>\n<p>所以在原来的基础上，封装出Editor对象，将通用方法挂载到Editor对象上实现复用。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f8862c4b7dab42ff821e2dda10d24290~tplv-k3u1fbpfcp-zoom-1.image\" alt></p>\n<p>实现代码：<a href=\"https://github.com/nihaojob/vue-fabric-editor/blob/bf36aa6ba093d0d603d68482d201f0c78d2b1f2c/src/core/index.js#L19\">https://github.com/nihaojob/vue-fabric-editor/blob/bf36aa6ba093d0d603d68482d201f0c78d2b1f2c/src/core/index.js#L19</a></p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a832545a57474923802f5337a8d2cee2~tplv-k3u1fbpfcp-zoom-1.image\" alt></p>\n<h3>2、辅助线</h3>\n<p>辅助线是很常见的必要功能，官方提供了辅助线方法，在官方仓库中，只需要引入方法即可。</p>\n<p>实现代码：<a href=\"https://github.com/fabricjs/fabric.js/blob/master/lib/aligning_guidelines.js\">https://github.com/fabricjs/fabric.js/blob/master/lib/aligning_guidelines.js</a></p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cb50b2869c664e879fdba2f316ac9cd9~tplv-k3u1fbpfcp-zoom-1.image\" alt></p>\n<h3>3、控制条样式</h3>\n<p>稿定设计和创客贴的元素控制条看起来都很精致，而fabric.js自带的控制条较为简陋，可以通过自定义样式方法把控制条修饰的稍微美观一些。</p>\n<p>实现代码：<a href=\"https://github.com/nihaojob/vue-fabric-editor/blob/main/src/core/initControls.js\">https://github.com/nihaojob/vue-fabric-editor/blob/main/src/core/initControls.js</a></p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2222e0689def499caf5b8416d7907760~tplv-k3u1fbpfcp-zoom-1.image\" alt><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/94f582bd8f2645a080b18b78ea80b8fc~tplv-k3u1fbpfcp-zoom-1.image\" alt></p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9214a3a0cf7246c49d191f7c20a6fccb~tplv-k3u1fbpfcp-zoom-1.image\" alt></p>\n<h3>4、右键菜单</h3>\n<p>fabric.js并没有自带右键菜单的功能，但可以监听到右键菜单事件，我们可以通过监听方法来实现右键菜单功能。</p>\n<p>实现代码：<a href=\"https://github.com/nihaojob/vue-fabric-editor/blob/bf36aa6ba093d0d603d68482d201f0c78d2b1f2c/src/components/mouseMenu.vue#L72\">https://github.com/nihaojob/vue-fabric-editor/blob/bf36aa6ba093d0d603d68482d201f0c78d2b1f2c/src/components/mouseMenu.vue#L72</a></p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6b3ceb6963d14ddfb53a92387497e796~tplv-k3u1fbpfcp-zoom-1.image\" alt></p>\n<h3>5、快捷键功能</h3>\n<p>快捷键可以提高操作效率，比如组合/拆分组合、复制、删除等，只需要将快捷键事件和Editor的功能方法做绑定即可快速实现快捷键功能。</p>\n<p>快捷键监听有现成的工具库<code>hotkeys-js</code>，只需要绑定事件即可。</p>\n<p>实现代码：<a href=\"https://github.com/nihaojob/vue-fabric-editor/blob/main/src/core/initHotKeys.js\">https://github.com/nihaojob/vue-fabric-editor/blob/main/src/core/initHotKeys.js</a></p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/63c2ee439f53461699f603734352f040~tplv-k3u1fbpfcp-zoom-1.image\" alt></p>\n<h3>6、锁定图层</h3>\n<p>锁定元素可以让元素不可编辑，比如下图中的白色背景元素，设置大小和位置后就不希望再选中和它，可以设置图层锁定，这样编辑上方元素时就会干扰到下方元素。</p>\n<p>使用<code>selectable</code>属性控制元素不可选中，需要注意的点是，当我们遍历所有元素时，要对锁定元素单独处理。</p>\n<p>实现代码：<a href=\"https://github.com/nihaojob/vue-fabric-editor/blob/bf36aa6ba093d0d603d68482d201f0c78d2b1f2c/src/components/lock.vue#L41\">https://github.com/nihaojob/vue-fabric-editor/blob/bf36aa6ba093d0d603d68482d201f0c78d2b1f2c/src/components/lock.vue#L41</a></p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4620334fc7a64756ba950e0fa4d50db8~tplv-k3u1fbpfcp-zoom-1.image\" alt></p>\n<h3>7、画布大小调整</h3>\n<p>最早的版本的画布大小调整就是对fabric.js的canvas大小做调整，这样做有2个问题，一是没办法将画布大小保存到json文件中，另外一个问题是缩小放画布时，缩小后画布颜色和背景颜色一致，无法区分画布的边界，效果较差。</p>\n<p>最后的实现思路是，使用矩形元素模拟画布区域，fabric.js的canvas大小根据视口DOM的宽高自适应，通过调整矩形元素属性来设置画布到大小和颜色，其他元素通过属相面板修改属性。这样就解决了上边的2个问题。</p>\n<p>实现代码：<a href=\"https://github.com/nihaojob/vue-fabric-editor/blob/main/src/core/initWorkspace.js\">https://github.com/nihaojob/vue-fabric-editor/blob/main/src/core/initWorkspace.js</a></p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6724b0d4ab37495eaf52b30c31c8da61~tplv-k3u1fbpfcp-zoom-1.image\" alt></p>\n<h3>8、元素画布超出区域</h3>\n<p>参考稿定设计和创客贴的编辑器，都有一个细节，就是当元素拖出画布区域后，看不到元素但可以展示控制条，由于画布是通过矩形模拟出来的，通过clipPath可以便捷的实现。</p>\n<p>实现代码：<a href=\"https://github.com/nihaojob/vue-fabric-editor/commit/8512e3293f991dc8b2633669c4feb1514dca9a02\">https://github.com/nihaojob/vue-fabric-editor/commit/8512e3293f991dc8b2633669c4feb1514dca9a02</a></p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/56a18f16ca244b3d929891711eabc959~tplv-k3u1fbpfcp-zoom-1.image\" alt></p>\n<h3>9、拖拽到画布</h3>\n<p>将基础元素添加到画布有两种方式，一种是点击元素，会添加到画布中央，另一种是直接拖拽元素到画布，可以将元素添加到指定位置，使用拖拽事件实现。</p>\n<p>实现代码：<a href=\"https://github.com/nihaojob/vue-fabric-editor/blob/bf36aa6ba093d0d603d68482d201f0c78d2b1f2c/src/components/tools.vue#L163\">https://github.com/nihaojob/vue-fabric-editor/blob/bf36aa6ba093d0d603d68482d201f0c78d2b1f2c/src/components/tools.vue#L163</a></p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ca86b6de9a144e5589de4f56624e845a~tplv-k3u1fbpfcp-zoom-1.image\" alt></p>\n<h3>10、渐变配置</h3>\n<p>渐变在背景、字体颜色上很常用，fabric.js有提供渐变的配置方法，我们只需要按照纯色、渐变2种方式设置颜色即可，功能已实现，细节需要优化，没有合并到main分支。</p>\n<p>实现代码：<a href=\"https://github.com/nihaojob/vue-fabric-editor/blob/f85fede86b37be0a22362cd68c346cab19ef507e/src/components/attribute.vue#L493\">https://github.com/nihaojob/vue-fabric-editor/blob/f85fede86b37be0a22362cd68c346cab19ef507e/src/components/attribute.vue#L493</a></p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/691a58842da74ef19a4ec8993c177acb~tplv-k3u1fbpfcp-zoom-1.image\" alt></p>\n<h2>结尾</h2>\n<p>开源过程中遇到很多志同道合的开发者，为项目提供思路、代码、PR ，让项目从0涨到了600star，感谢大家的帮助，希望能够继续迭代，打磨成像稿定设计和创客贴一样好用的开源图形编辑器。</p>\n<p>目前的版本仍在继续迭代，很多细节还不完善，基础功能还在补充，比如滤镜设置、图片替换、图片裁剪、字体样式模板等，还有一些文档、vue3升级、单元测试的工作。</p>\n<p>在开发的过程中我的收获也很大，如果你也比较感兴趣，是fabric.js的爱好者或者自己也在开发类似的项目，欢迎加入交流群，期待你的Issue和PR，一起打造一款好用的设计编辑器。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/73edacbc23c24ae289b87fc54687ff55~tplv-k3u1fbpfcp-zoom-1.image\" alt></p>\n<h3>致谢：</h3>\n<ul>\n<li><a href=\"https://github.com/Qiu-Jun\">June</a> 多次深夜为项目贡献代码，提供快捷键、右键菜单等功能。</li>\n<li><a href=\"https://github.com/xiaozeo\">xiaozeo</a> 宝妈百忙中为项目提交代码，让属性面板更美观。</li>\n<li><a href=\"https://github.com/icleitoncosta\">icleitoncosta</a> 异国他乡的开发者朋友，提供了国际化功能。</li>\n<li><a href=\"https://github.com/asang28\">asang28</a> 为项目提供了vue3版本代码。</li>\n<li>晗萧℡ 会自己写编辑器的设计师，多次为项目提供代码示例。</li>\n<li>RHS 为项目提供缩放思路、标尺代码。</li>\n<li>放牛哥 为项目提供代码和实现思路。</li>\n<li>冯志辉 一直在关注我们，为我们加油打气。</li>\n<li>…</li>\n</ul>\n<p>篇幅有限，不再一一列举名单，感谢大家的支持与帮助，希望vue-fabric-editor在未来的日子里不负期望，和大家一起越变越好。</p>\n</div>",
    "title": "fabric.js开发图片编辑器的细节实现",
    "last_reply_at": "2023-02-28T02:59:36.793Z",
    "good": false,
    "top": false,
    "reply_count": 1,
    "visit_count": 235156,
    "create_at": "2023-02-16T08:46:13.152Z",
    "author": {
      "loginname": "nihaojob",
      "avatar_url": "https://avatars.githubusercontent.com/u/13534626?v=4&s=120"
    }
  }
]
export default dataList